<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>QC: Core QuickChick</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/plf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
<ul id='menu'>
   <a href='index.html'><li class='section_name'>Property-Based Testing </li></a>
   <a href='toc.html'><li>Table of Contents</li></a>
   <a href='coqindex.html'><li>Index</li></a>
   <a href='deps.html'><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">QC<span class="subtitle">Core QuickChick</span></h1>



<div class="doc">
<a name="lab48"></a><h1 class="section">Generators</h1>

<div class="paragraph"> </div>

 The heart of property-based random testing is random generation of
    inputs.  
</div>

<div class="doc">
<a name="lab49"></a><h2 class="section">The <span class="inlinecode"><span class="id" type="var">G</span></span> Monad</h2>

<div class="paragraph"> </div>

 In QuickChick, a generator for elements of some type <span class="inlinecode"><span class="id" type="var">A</span></span> belongs
    to the type <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode"><span class="id" type="var">A</span></span>.  Intuitively, this type describes functions
    that take a random seed to an element of <span class="inlinecode"><span class="id" type="var">A</span></span>, plus a new random
    seed to be used for generating further random values.  (We will
    see below that <span class="inlinecode"><span class="id" type="var">G</span></span> is actually a bit richer than this, but this
    intuition will do for now.)

<div class="paragraph"> </div>

    QuickChick provides a number of primitives for building
    generators.  First, <span class="inlinecode"><span class="id" type="var">returnGen</span></span> takes a constant value and yields
    a generator that always returns this value. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">returnGen</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
       returnGen : ?A -&gt; G ?A 
</pre>

<div class="paragraph"> </div>

 We can see how it behaves by using the <span class="inlinecode"><span class="id" type="var">Sample</span></span> command: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">returnGen</span> 42).<br/>
</div>

<div class="doc">
<pre>     ===&gt;
         [42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42] 
</pre>

<div class="paragraph"> </div>

 Next, given a random generator for <span class="inlinecode"><span class="id" type="var">A</span></span> and a <i>function</i> <span class="inlinecode"><span class="id" type="var">f</span></span> taking
    an element of <span class="inlinecode"><span class="id" type="var">A</span></span> and yielding a random generator for <span class="inlinecode"><span class="id" type="var">B</span></span>, we can
    plumb the two together into a generator for <span class="inlinecode"><span class="id" type="var">B</span></span> that works by
    internally generating a random <span class="inlinecode"><span class="id" type="var">A</span></span> and applying <span class="inlinecode"><span class="id" type="var">f</span></span> to it. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">bindGen</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
        bindGen : G ?A -&gt; (?A -&gt; G ?B) -&gt; G ?B 
</pre>

<div class="paragraph"> </div>

 With these two primitives in hand, we can make <span class="inlinecode"><span class="id" type="var">G</span></span> an instance of
    the <span class="inlinecode"><span class="id" type="var">Monad</span></span> typeclass.  (This <span class="inlinecode"><span class="id" type="keyword">Instance</span></span> should really be defined
    within QuickChick itself, but it are not at the moment.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gMonad</span> : `{<span class="id" type="var">Monad</span> <span class="id" type="var">G</span>} | 3 :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ret</span> := @<span class="id" type="var">returnGen</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bind</span> := @<span class="id" type="var">bindGen</span><br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
<a name="lab50"></a><h2 class="section">Primitive generators</h2>

<div class="paragraph"> </div>

 Next, QuickChick provides primitive generators for booleans,
    natural numbers and integers. They are accessed via the <span class="inlinecode"><span class="id" type="var">choose</span></span>
    combinator. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">ChoosableFromInterval</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> @<span class="id" type="var">choose</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
        @choose
           : forall A : Type, ChoosableFromInterval A -&gt; A * A -&gt; G A  
</pre>

<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="var">ChoosableFromInterval</span></span> typeclass describes primitive types
    <span class="inlinecode"><span class="id" type="var">A</span></span>, like natural numbers and integers (<span class="inlinecode"><span class="id" type="var">Z</span></span>), for which it makes
    sense to randomly generate elements from a given interval. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">choose</span> (0,10)).<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
       [ 1, 2, 1, 9, 8, 1, 3, 6, 2, 1, 8, 0, 1, 1, 3, 5, 4, 10, 4, 6 ] 
</pre>

<div class="paragraph"> </div>

<a name="lab51"></a><h4 class="section">Exercise: 1 star, optional (cfi)</h4>
 Print out the definition of <span class="inlinecode"><span class="id" type="var">ChoosableFromInterval</span></span>.  Can you
    understand what it means?  <span class="proofbox">&#9744;</span> 
</div>

<div class="doc">
<a name="lab52"></a><h2 class="section">Lists</h2>

<div class="paragraph"> </div>

 Since they are a very commonly used compound datatype, lists have
    special combinators in QuickChick: <span class="inlinecode"><span class="id" type="var">listOf</span></span> and <span class="inlinecode"><span class="id" type="var">vectorOf</span></span>. 
<div class="paragraph"> </div>

 The <span class="inlinecode"><span class="id" type="var">listOf</span></span> combinator takes as input a generator for elements of
    type <span class="inlinecode"><span class="id" type="var">A</span></span> and returns a generator for lists of <span class="inlinecode"><span class="id" type="var">A</span></span>s. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">listOf</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
      listOf : G ?A -&gt; G (list ?A) 
</pre>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">listOf</span> (<span class="id" type="var">choose</span> (0,4))).<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
      [ [ 0, 3, 2, 0 ], 
        [ 1, 3, 4, 1, 0, 3, 0, 2, 2, 3, 2, 2, 2, 0, 4, 2, 3, 0, 1 ], 
        [ 3, 4, 3, 1, 2, 4, 4, 1, 0, 3, 4, 3, 2, 2, 4, 4, 1 ], 
        [ 0 ], 
        [ 4, 2, 3 ], 
        [ 3, 3, 4, 0, 1, 4, 3, 2, 4, 1 ], 
        [ 0, 4 ], 
        [  ], 
        [ 1, 0, 1, 3, 1 ], 
        [ 0, 0 ], 
        [ 1, 4 ], 
        [ 4, 3, 2, 0, 2, 2, 4, 0 ], 
        [ 1, 1, 0, 0, 1, 4 ], 
        [ 2, 0, 2, 1, 3, 3 ], 
        [ 4, 3, 3, 0, 1 ], 
        [ 3, 3, 3 ], 
        [ 3, 2, 4 ], 
        [ 1, 2 ], 
        [  ], 
        [  ] ]
</pre>

<div class="paragraph"> </div>

 The second combinator, <span class="inlinecode"><span class="id" type="var">vectorOf</span></span>, receives an additional numeric
    argument <span class="inlinecode"><span class="id" type="var">n</span></span>, the length of the list to be generated. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">vectorOf</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
      vectorOf : nat -&gt; G ?A -&gt; G (list ?A) 
</pre>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">vectorOf</span> 3 (<span class="id" type="var">choose</span> (0,4))).<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
      [ [0, 1, 4], 
        [1, 1, 0], 
        [3, 3, 3], 
        [0, 2, 1], 
        [1, 3, 2], 
        [3, 3, 0], 
        [3, 0, 4], 
        [2, 3, 3], 
        [3, 2, 4], 
        [1, 2, 3], 
        [2, 0, 4]  ]
</pre>

<div class="paragraph"> </div>

 This raises a question.  It's clear how <span class="inlinecode"><span class="id" type="var">vectorOf</span></span> decides how big
    to make its lists (we tell it!), but how does <span class="inlinecode"><span class="id" type="var">listOf</span></span> do it?  The
    answer is hidden inside <span class="inlinecode"><span class="id" type="var">G</span></span>.

<div class="paragraph"> </div>

    In addition to handling random-seed plumbing, the <span class="inlinecode"><span class="id" type="var">G</span></span> monad also
    maintains a "current maximum size" (in the style of a "reader
    monad", if you like that terminology): a natural number <span class="inlinecode"><span class="id" type="var">n</span></span> that
    serves as the upper bound on the depth of generated objects.  When
    it is searching for counterexamples, QuickChick progressively
    tries larger and larger values for <span class="inlinecode"><span class="id" type="var">n</span></span>, in order to explore larger
    and deeper part of the search space.

<div class="paragraph"> </div>

    Each generator can choose to interpret the size bound however it
    wants, and there is no enforced guarantee that generators pay any
    attention to it at all; however, it is good practice to respect
    this bound when programming new generators. 
</div>

<div class="doc">
<a name="lab53"></a><h2 class="section">Custom Generators</h2>

<div class="paragraph"> </div>

 Naturally, we often need generators involving user-defined
    datatypes.  Here's a simple one to play with: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">color</span> := <span class="id" type="var">Red</span> | <span class="id" type="var">Green</span> | <span class="id" type="var">Blue</span> | <span class="id" type="var">Yellow</span>.<br/>
</div>

<div class="doc">
In order for commands like <span class="inlinecode"><span class="id" type="var">Sample</span></span> to display colors, we should
    make <span class="inlinecode"><span class="id" type="var">color</span></span> an instance of the <span class="inlinecode"><span class="id" type="keyword">Show</span></span> typeclass: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">String</span>. <span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">string</span>.<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">show_color</span> : <span class="id" type="keyword">Show</span> <span class="id" type="var">color</span> :=<br/>
&nbsp;&nbsp;{| <span class="id" type="var">show</span> <span class="id" type="var">c</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">c</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Red</span>    ⇒ "Red"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Green</span>  ⇒ "Green"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Blue</span>   ⇒ "Blue"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Yellow</span> ⇒ "Yellow"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;|}.<br/>
</div>

<div class="doc">
Now, to generate a random color, we just need to pick one of the
    constructors <span class="inlinecode"><span class="id" type="var">Red</span></span>, <span class="inlinecode"><span class="id" type="var">Green</span></span>, <span class="inlinecode"><span class="id" type="var">Blue</span></span>, or <span class="inlinecode"><span class="id" type="var">Yellow</span></span>. This is done
    using <span class="inlinecode"><span class="id" type="var">elements</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">elements</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
      elements : ?A -&gt; list ?A -&gt; G ?A 
</pre>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">genColor'</span> : <span class="id" type="var">G</span> <span class="id" type="var">color</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">elements</span> <span class="id" type="var">Red</span> [ <span class="id" type="var">Red</span> ; <span class="id" type="var">Green</span> ; <span class="id" type="var">Blue</span> ; <span class="id" type="var">Yellow</span> ].<br/>

<br/>
<span class="id" type="var">Sample</span> <span class="id" type="var">genColor'</span>.<br/>
</div>

<div class="doc">
<pre>     ===&gt; 
     [Red, Green, Blue, Blue, Red, Yellow, Blue, Red, Blue, Blue, Red] 
</pre>

<div class="paragraph"> </div>

 The first argument to <span class="inlinecode"><span class="id" type="var">elements</span></span> serves as a default result.  If
    its list argument is not empty, <span class="inlinecode"><span class="id" type="var">elements</span></span> returns a generator
    that always picks an element of that list; otherwise the generator
    always returns the default object.  This makes Coq's totality
    checker happy, but makes <span class="inlinecode"><span class="id" type="var">elements</span></span> a little awkward to use, since
    typically its second argument will be a non-empty constant list.
    To make this common case smoother, QuickChick provides convenient
    notations that automatically extract the default.  &lt;&lt;
     " 'elems' <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode"></span> " := elements x (cons x nil)
     " 'elems' <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode"></span> " := elements x (cons x (cons y nil))
     " 'elems' <span class="inlinecode"></span> <span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" type="var">y</span></span> <span class="inlinecode">;</span> <span class="inlinecode">..</span> <span class="inlinecode">;</span> <span class="inlinecode"><span class="id" type="var">z</span></span> <span class="inlinecode"></span> " := elements x
     " 'elems' ( x ;; l ) " := elements x (cons x l)
&gt;&gt;

<div class="paragraph"> </div>

 Armed with <span class="inlinecode"><span class="id" type="var">elems</span></span>, we can write a <span class="inlinecode"><span class="id" type="var">color</span></span> generator the way we'd
    hope. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">genColor</span> : <span class="id" type="var">G</span> <span class="id" type="var">color</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">elems</span> [ <span class="id" type="var">Red</span> ; <span class="id" type="var">Green</span> ; <span class="id" type="var">Blue</span> ; <span class="id" type="var">Yellow</span> ].<br/>

<br/>
<span class="id" type="var">Sample</span> <span class="id" type="var">genColor</span>.<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       [Red, Green, Blue, Blue, Red, Yellow, Blue, Red, Blue, Blue, Red] 
</pre>

<div class="paragraph"> </div>

 For more complicated ADTs, QuickChick provides more combinators.
    We will showcase these using everyone's favorite datatype: trees!

<div class="paragraph"> </div>

    Our trees are standard polymorphic binary trees; either <span class="inlinecode"><span class="id" type="var">Leaf</span></span>s or
    <span class="inlinecode"><span class="id" type="var">Node</span></span>s containing some payload of type <span class="inlinecode"><span class="id" type="var">A</span></span> and two subtrees. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">Tree</span> <span class="id" type="var">A</span> :=<br/>
| <span class="id" type="var">Leaf</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">A</span><br/>
| <span class="id" type="var">Node</span> : <span class="id" type="var">A</span> → <span class="id" type="var">Tree</span> <span class="id" type="var">A</span> → <span class="id" type="var">Tree</span> <span class="id" type="var">A</span> → <span class="id" type="var">Tree</span> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <span class="id" type="var">Leaf</span> {<span class="id" type="var">A</span>}.<br/>
<span class="id" type="var">Arguments</span> <span class="id" type="var">Node</span> {<span class="id" type="var">A</span>} <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>
</div>

<div class="doc">
Before getting to generators for trees, we again give a
    straightforward <span class="inlinecode"><span class="id" type="keyword">Show</span></span> instance.  (The need for a local <span class="inlinecode"><span class="id" type="keyword">let</span></span> <span class="inlinecode"><span class="id" type="var">fix</span></span>
    declaration stems from the fact that Coq's typeclasses (unlike
    Haskell's) are not automatically recursive.  We could
    alternatively define <span class="inlinecode"><span class="id" type="var">aux</span></span> with a separate top-level
    <span class="inlinecode"><span class="id" type="keyword">Fixpoint</span></span>.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">showTree</span> {<span class="id" type="var">A</span>} `{<span class="id" type="var">_</span> : <span class="id" type="keyword">Show</span> <span class="id" type="var">A</span>} : <span class="id" type="keyword">Show</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;{| <span class="id" type="var">show</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">fix</span> <span class="id" type="var">aux</span> <span class="id" type="var">t</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ "Leaf"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Node (" ++ <span class="id" type="var">show</span> <span class="id" type="var">x</span> ++ ") (" ++ <span class="id" type="var">aux</span> <span class="id" type="var">l</span> ++ ") (" ++ <span class="id" type="var">aux</span> <span class="id" type="var">r</span> ++ ")"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">in</span> <span class="id" type="var">aux</span><br/>
&nbsp;&nbsp;|}.<br/>
</div>

<div class="doc">
Now we come to the first <i>generator combinator</i>, called <span class="inlinecode"><span class="id" type="var">oneof</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">oneof</span>.<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       oneof : G ?A -&gt; list (G ?A) -&gt; G ?A 
</pre>

<div class="paragraph"> </div>

 This combinator takes a default generator and a list of
    generators, and it picks one of the generators from the list
    uniformly at random (as long as the list is not empty, in which
    case it picks from the default generator).  As for <span class="inlinecode"><span class="id" type="var">elements</span></span>,
    QuickChick introduces a more convenient notation <span class="inlinecode"><span class="id" type="var">oneOf</span></span> to hide
    this default element.

<div class="paragraph"> </div>

    At this point, Coq's termination checker is going to save us from
    shooting ourselves in the foot. The "obvious" first generator that
    one might write is the following function <span class="inlinecode"><span class="id" type="var">genTree</span></span>, which
    generates either a <span class="inlinecode"><span class="id" type="var">Leaf</span></span> or else a <span class="inlinecode"><span class="id" type="var">Node</span></span> whose subtrees are
    generated recursively (and whose payload is produced by a
    generator <span class="inlinecode"><span class="id" type="var">g</span></span> for elements of type <span class="inlinecode"><span class="id" type="var">A</span></span>).
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<pre>
     Fixpoint genTree {A} (g : G A) : G (Tree A) :=
        oneOf [ ret Leaf ;;
                liftM3 Node g (genTree g) (genTree g) ].
</pre>

<div class="paragraph"> </div>

 Of course, this fixpoint will not pass Coq's termination
    checker. Attempting to justify this fixpoint informally, one might
    first say that at some point the random generation will pick a
    <span class="inlinecode"><span class="id" type="var">Leaf</span></span> so it will eventually terminate.  But the termination
    checker cannot understand this kind of probabilistic reasoning.
    Moreover, even informally, the reasoning is wrong: Every time we
    choose to generate a <span class="inlinecode"><span class="id" type="var">Node</span></span>, we create two separate branches that
    must both be terminated with leaves.  From this, it is not hard to
    show that the <i>expected</i> size of the generated trees is actually
    infinite!

<div class="paragraph"> </div>

    The solution is to use the standard "fuel" idiom that all Coq
    users know.  We add an additional natural number <span class="inlinecode"><span class="id" type="var">sz</span></span> as a
    parameter.  We decrease this size in each recursive call, and when
    it reaches <span class="inlinecode"><span class="id" type="var">O</span></span>, we always generate <span class="inlinecode"><span class="id" type="var">Leaf</span></span>.  Thus, the initial <span class="inlinecode"><span class="id" type="var">sz</span></span>
    parameter serves as a bound on the depth of the tree. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">genTreeSized</span> {<span class="id" type="var">A</span>} (<span class="id" type="var">sz</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">g</span> : <span class="id" type="var">G</span> <span class="id" type="var">A</span>) : <span class="id" type="var">G</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">sz</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">ret</span> <span class="id" type="var">Leaf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">sz'</span> ⇒ <span class="id" type="var">oneOf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" type="var">ret</span> <span class="id" type="var">Leaf</span> ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">liftM3</span> <span class="id" type="var">Node</span> <span class="id" type="var">g</span> (<span class="id" type="var">genTreeSized</span> <span class="id" type="var">sz'</span> <span class="id" type="var">g</span>) (<span class="id" type="var">genTreeSized</span> <span class="id" type="var">sz'</span> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">genTreeSized</span> 3 (<span class="id" type="var">choose</span>(0,3))).<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       [ Leaf,
         Leaf,
         Node (3) (Node (0) (Leaf) (Leaf))
                  (Node (2) (Leaf) (Node (3) (Leaf) (Leaf))),
         Leaf,
         Leaf,
         Leaf,
         Node (1) (Leaf) (Node (1) (Leaf) (Node (0) (Leaf) (Leaf))),
         Leaf,
         Node (3) (Leaf) (Leaf),
         Node (1) (Leaf) (Leaf),
         Leaf,
         Leaf,
         Node (0) (Leaf) (Node (0) (Leaf) (Node (2) (Leaf) (Leaf))),
         Node (0) (Node (2) (Node (3) (Leaf) (Leaf)) (Leaf)) (Leaf),
         Node (0) (Leaf) (Leaf),
         Leaf,
         Leaf,
         Leaf,
         Leaf,
         Leaf ]
</pre>

<div class="paragraph"> </div>

 While this generator succeeds in avoiding nontermination, we can
    see just by observing the result of <span class="inlinecode"><span class="id" type="var">Sample</span></span> that there is a
    problem: <span class="inlinecode"><span class="id" type="var">genTreeSized</span></span> produces way too many <span class="inlinecode"><span class="id" type="var">Leaf</span></span>s!  This is
    actually to be expected, since half the time we generate a <span class="inlinecode"><span class="id" type="var">Leaf</span></span>
    right at the outset. We can obtain more interesting trees more
    often if we skew the distribution towards <span class="inlinecode"><span class="id" type="var">Node</span></span>s using the most
    expressive QuickChick combinator, <span class="inlinecode"><span class="id" type="var">frequency</span></span> and its associated
    default-lifting notation <span class="inlinecode"><span class="id" type="var">freq</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">frequency</span>.<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       frequency : G ?A -&gt; seq (nat * G ?A) -&gt; G ?A 
</pre>

<div class="paragraph"> </div>

 The more convenient form, <span class="inlinecode"><span class="id" type="var">freq</span></span>, takes a list of generators, each
    tagged with a natural number that serves as the weight of that
    generator.  For example, in the following generator, a <span class="inlinecode"><span class="id" type="var">Leaf</span></span> will
    be generated 1 / (sz + 1) of the time and a <span class="inlinecode"><span class="id" type="var">Node</span></span> the remaining
    sz / (sz + 1) of the time.
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">genTreeSized'</span> {<span class="id" type="var">A</span>} (<span class="id" type="var">sz</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">g</span> : <span class="id" type="var">G</span> <span class="id" type="var">A</span>) : <span class="id" type="var">G</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">sz</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">ret</span> <span class="id" type="var">Leaf</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">sz'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">freq</span> [ (1,  <span class="id" type="var">ret</span> <span class="id" type="var">Leaf</span>) ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">sz</span>, <span class="id" type="var">liftM3</span> <span class="id" type="var">Node</span> <span class="id" type="var">g</span> (<span class="id" type="var">genTreeSized'</span> <span class="id" type="var">sz'</span> <span class="id" type="var">g</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">genTreeSized'</span> <span class="id" type="var">sz'</span> <span class="id" type="var">g</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">genTreeSized'</span> 3 (<span class="id" type="var">choose</span>(0,3))).<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
         [ Node (3) (Node (1) (Node (3) (Leaf) (Leaf)) (Leaf)) 
                    (Node (0) (Leaf) (Node (3) (Leaf) (Leaf))),
           Leaf,
           Node (2) (Node (1) (Leaf) (Leaf)) (Leaf),
           Node (0) (Leaf) (Node (0) (Node (2) (Leaf) (Leaf))
                                     (Node (0) (Leaf) (Leaf))),
           Node (1) (Node (2) (Leaf) (Node (0) (Leaf) (Leaf))) (Leaf),
           Node (0) (Node (0) (Leaf) (Node (3) (Leaf) (Leaf)))
                    (Node (2) (Leaf) (Leaf)),
           Node (1) (Node (3) (Node (2) (Leaf) (Leaf)) (Node (3) (Leaf) (Leaf)))
                    (Node (1) (Leaf) (Node (2) (Leaf) (Leaf))),
           Node (0) (Node (0) (Node (0) (Leaf) (Leaf)) (Node (1) (Leaf) (Leaf))) 
                    (Node (2) (Node (3) (Leaf) (Leaf)) (Node (0) (Leaf) (Leaf))),
           Node (2) (Node (2) (Leaf) (Leaf)) (Node (1) (Node (2) (Leaf) (Leaf))
                                                       (Node (2) (Leaf) (Leaf))),
           Node (2) (Node (3) (Node (2) (Leaf) (Leaf)) (Leaf)) 
                    (Node (0) (Node (2) (Leaf) (Leaf)) (Leaf)),
           Leaf,
           Node (2) (Node (3) (Node (3) (Leaf) (Leaf)) (Leaf)) (Leaf),
           Leaf,
           Node (1) (Leaf) (Leaf),
           Leaf,
           Node (1) (Node (2) (Leaf) (Node (3) (Leaf) (Leaf))) 
                    (Node (0) (Leaf) (Node (1) (Leaf) (Leaf))),
           Leaf,
           Node (3) (Node (0) (Node (0) (Leaf) (Leaf)) (Leaf)) 
                    (Node (0) (Leaf) (Node (2) (Leaf) (Leaf))),
           Node (2) (Node (2) (Node (0) (Leaf) (Leaf)) (Leaf)) 
                    (Node (1) (Leaf) (Node (2) (Leaf) (Leaf))),
           Leaf ]
</pre>

<div class="paragraph"> </div>

 This looks better. 
<div class="paragraph"> </div>

<a name="lab54"></a><h4 class="section">Exercise: 2 stars (genListSized)</h4>
 Write a sized generator for lists, following <span class="inlinecode"><span class="id" type="var">genTreeSized'</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 
<div class="doc less-space">
<div class="paragraph"> </div>

<a name="lab55"></a><h4 class="section">Exercise: 3 stars (genColorOption)</h4>
 Write a custom generator for values of type <span class="inlinecode"><span class="id" type="var">option</span></span> <span class="inlinecode"><span class="id" type="var">color</span></span>.  Make
    it generate <span class="inlinecode"><span class="id" type="var">None</span></span> about 1/10th of the time, and make it generate
    <span class="inlinecode"><span class="id" type="var">Some</span></span> <span class="inlinecode"><span class="id" type="var">Red</span></span> three times as often as the other colors. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<span class="proofbox">&#9744;</span> 

<div class="doc">
<a name="lab56"></a><h2 class="section">Checkers</h2>

<div class="paragraph"> </div>

 To showcase how such a generator could be used in practice for
    finding counterexamples, suppose we define a function for
    "mirroring" a tree &mdash; swapping its left and right subtrees
    recursively. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">mirror</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) : <span class="id" type="var">Tree</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ <span class="id" type="var">Leaf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒ <span class="id" type="var">Node</span> <span class="id" type="var">x</span> (<span class="id" type="var">mirror</span> <span class="id" type="var">r</span>) (<span class="id" type="var">mirror</span> <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
To formulate a property about <span class="inlinecode"><span class="id" type="var">mirror</span></span>, we also need a simple
    structural equality on trees: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">eq_tree</span> (<span class="id" type="var">t<sub>1</sub></span> <span class="id" type="var">t<sub>2</sub></span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) : <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t<sub>1</sub></span>, <span class="id" type="var">t<sub>2</sub></span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Leaf</span>, <span class="id" type="var">Leaf</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">r<sub>1</sub></span>, <span class="id" type="var">Node</span> <span class="id" type="var">x<sub>2</sub></span> <span class="id" type="var">l<sub>2</sub></span> <span class="id" type="var">r<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">beq_nat</span> <span class="id" type="var">x<sub>1</sub></span> <span class="id" type="var">x<sub>2</sub></span> &amp;&amp; <span class="id" type="var">eq_tree</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> &amp;&amp; <span class="id" type="var">eq_tree</span> <span class="id" type="var">r<sub>1</sub></span> <span class="id" type="var">r<sub>2</sub></span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We expect that <span class="inlinecode"><span class="id" type="var">mirror</span></span> should be "unipotent": mirroring a tree
    twice yields the original tree.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">mirrorP</span> (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) := <span class="id" type="var">eq_tree</span> (<span class="id" type="var">mirror</span> (<span class="id" type="var">mirror</span> <span class="id" type="var">t</span>)) <span class="id" type="var">t</span>.<br/>
</div>

<div class="doc">
Now we want to use our generator to create a lot of random trees
    and, for each one, check whether <span class="inlinecode"><span class="id" type="var">mirrorP</span></span> returns <span class="inlinecode"><span class="id" type="var">true</span></span> or
    <span class="inlinecode"><span class="id" type="var">false</span></span>.  That is, we want to use <span class="inlinecode"><span class="id" type="var">mirrorP</span></span> to build a <i>generator
    for test results</i>.

<div class="paragraph"> </div>

    Let's open a playground module so we can show simplified versions
    of the actual QUickChick definitions. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">CheckerPlayground1</span>.<br/>
</div>

<div class="doc">
First, we need a type of test results &mdash; let's call it <span class="inlinecode"><span class="id" type="var">Result</span></span>.
    For the moment, think of <span class="inlinecode"><span class="id" type="var">Result</span></span> as just an enumerated type with
    constructors <span class="inlinecode"><span class="id" type="var">Success</span></span> and <span class="inlinecode"><span class="id" type="var">Failure</span></span>.  
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">Result</span> := <span class="id" type="var">Success</span> | <span class="id" type="var">Failure</span>.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">showResult</span> : <span class="id" type="keyword">Show</span> <span class="id" type="var">Result</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">show</span> <span class="id" type="var">r</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">r</span> <span class="id" type="keyword">with</span> <span class="id" type="var">Success</span> ⇒ "Success" | <span class="id" type="var">Failure</span> ⇒ "Failure" <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
Then we can define the type <span class="inlinecode"><span class="id" type="var">Checker</span></span> to be <span class="inlinecode"><span class="id" type="var">G</span></span> <span class="inlinecode"><span class="id" type="var">Result</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Checker</span> := <span class="id" type="var">G</span> <span class="id" type="var">Result</span>.<br/>
</div>

<div class="doc">
To check <span class="inlinecode"><span class="id" type="var">mirrorP</span></span>, we need a way to build a <span class="inlinecode"><span class="id" type="var">Checker</span></span> out of a
    function from trees to booleans.  But let's start simpler and see
    how to build a checker out of a <span class="inlinecode"><span class="id" type="var">bool</span></span>. 
<div class="paragraph"> </div>

 <div style="background-color:lightgray; color:red; margin:10px; padding:10px; "> Words needed 
</div> 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Class</span> <span class="id" type="var">Checkable</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> : <span class="id" type="var">A</span> → <span class="id" type="var">Checker</span><br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">checkableBool</span> : <span class="id" type="var">Checkable</span> <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> <span class="id" type="var">b</span> := <span class="id" type="keyword">if</span> <span class="id" type="var">b</span> <span class="id" type="keyword">then</span> <span class="id" type="var">ret</span> <span class="id" type="var">Success</span> <span class="id" type="keyword">else</span> <span class="id" type="var">ret</span> <span class="id" type="var">Failure</span><br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">CheckerPlayground1</span>.<br/>
</div>

<div class="doc">
Let's see what happens if we sample our favorite booleans.  (We
    need to exit the playground so that we can do <span class="inlinecode"><span class="id" type="var">Sample</span></span>, because
    <span class="inlinecode"><span class="id" type="var">Sample</span></span> is implemented internally via extraction to OCaml, which
    usually does not work from inside a <span class="inlinecode"><span class="id" type="keyword">Module</span></span>.) 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground1.checker</span> <span class="id" type="var">true</span>).<br/>
</div>

<div class="doc">
<pre>
      [Success, Success, Success, Success, Success, Success, Success, 
       Success, Success, Success, Success]
</pre>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground1.checker</span> <span class="id" type="var">false</span>).<br/>
</div>

<div class="doc">
<pre>
      [Failure, Failure, Failure, Failure, Failure, Failure, Failure, 
       Failure, Failure, Failure, Failure]
</pre>

<div class="paragraph"> </div>

 What we've done so far may look a a bit strange, since our
    checkers always generate constant results.  We'll make things more
    interesting in a bit, but first let's pause to define one more
    instance of <span class="inlinecode"><span class="id" type="var">Checkable</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">CheckerPlayground2</span>.<br/>
<span class="id" type="keyword">Export</span> <span class="id" type="var">CheckerPlayground1</span>.<br/>
</div>

<div class="doc">
A decidable <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> is not too different from a boolean, so we
    should be able to build a checker from that. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">checkableDec</span> `{<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>} `{<span class="id" type="var">Dec</span> <span class="id" type="var">P</span>} : <span class="id" type="var">Checkable</span> <span class="id" type="var">P</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> <span class="id" type="var">p</span> := <span class="id" type="keyword">if</span> <span class="id" type="var">P</span>? <span class="id" type="keyword">then</span> <span class="id" type="var">ret</span> <span class="id" type="var">Success</span> <span class="id" type="keyword">else</span> <span class="id" type="var">ret</span> <span class="id" type="var">Failure</span><br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
(The definition looks a bit strange since it doesn't use its
    argument <span class="inlinecode"><span class="id" type="var">p</span></span>.  The intuition is that all the information in <span class="inlinecode"><span class="id" type="var">p</span></span> is
    already encoded in <span class="inlinecode"><span class="id" type="var">P</span></span>!) 
<div class="paragraph"> </div>

 Now suppose we pose a couple of (decidable) conjectures: 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Conjecture</span> <span class="id" type="var">c<sub>1</sub></span> : 0 = 42.<br/>
<span class="id" type="var">Conjecture</span> <span class="id" type="var">c<sub>2</sub></span> : 41 + 1 = 42.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">CheckerPlayground2</span>.<br/>
</div>

<div class="doc">
The somewhat astononishing thing is that, even though these are
    <i>conjectures</i> (we haven't proved them, so the "evidence" that Coq
    has for them internally is just an uninstantiated "evar"), but &mdash;
    because the <span class="inlinecode"><span class="id" type="var">Checkable</span></span> instance for decidable properties does not
    look at its argument &mdash; we can still build checkers from them and
    sample from these checkers! 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground1.checker</span> <span class="id" type="var">CheckerPlayground2.c1</span>).<br/>
</div>

<div class="doc">
<pre>
      [Failure, Failure, Failure, Failure, Failure, Failure, Failure, 
       Failure, Failure, Failure, Failure]
</pre>

</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground1.checker</span> <span class="id" type="var">CheckerPlayground2.c2</span>).<br/>
</div>

<div class="doc">
<pre>
      [Success, Success, Success, Success, Success, Success, Success, 
       Success, Success, Success, Success]
</pre>

<div class="paragraph"> </div>

 Again, the intuition is that, although we didn't present proofs,
    Coq already "knows" either a proof or a disproof of each of these
    conjectures because they are decidable. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">CheckerPlayground3</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">CheckerPlayground2</span>.<br/>
</div>

<div class="doc">
Now let's go back to <span class="inlinecode"><span class="id" type="var">mirrorP</span></span>.

<div class="paragraph"> </div>

    We have seen that the result of <span class="inlinecode"><span class="id" type="var">mirrorP</span></span> is <span class="inlinecode"><span class="id" type="var">Checkable</span></span>.  What we
    need is a way of taking a function returning a checkable thing and
    making the function itself checkable.  We can easily do this, as
    long as the argument type of the function is something we know how
    to generate! 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">forAll</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} `{<span class="id" type="var">Checkable</span> <span class="id" type="var">B</span>} (<span class="id" type="var">g</span> : <span class="id" type="var">G</span> <span class="id" type="var">A</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> → <span class="id" type="var">B</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">a</span> &lt;- <span class="id" type="var">g</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">checker</span> (<span class="id" type="var">f</span> <span class="id" type="var">a</span>).<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">CheckerPlayground3</span>.<br/>

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground3.forAll</span> (<span class="id" type="var">genTreeSized'</span> 3 (<span class="id" type="var">choose</span>(0,3))) <span class="id" type="var">mirrorP</span>).<br/>
</div>

<div class="doc">
<pre>
      [Success, Success, Success, Success, Success, Success, Success, 
       Success, Success, Success, Success]
</pre>

<div class="paragraph"> </div>

 Excellent: It looks like lots of tests are succeeding.  Now let's
    try defining a bad property and see if we can detect that it's bad... 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">faultyMirrorP</span> (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) := <span class="id" type="var">eq_tree</span> (<span class="id" type="var">mirror</span> <span class="id" type="var">t</span>) <span class="id" type="var">t</span>.<br/>

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground3.forAll</span> (<span class="id" type="var">genTreeSized'</span> 3 (<span class="id" type="var">choose</span>(0,3))) <span class="id" type="var">faultyMirrorP</span>).<br/>
</div>

<div class="doc">
<pre>
      [Failure, Success, Failure, Success, Success, Success, Failure, 
       Success, Failure, Failure, Success]
</pre>

<div class="paragraph"> </div>

 Great &mdash; looks like a good number of tests are failing now.
    There's only one fly in the ointment: What <i>are</i> the tests that
    are failing?  We can tell that the property is bad, but we can't
    see the counterexamples!

<div class="paragraph"> </div>

    We can fix this by going back to the beginning and enriching the
    <span class="inlinecode"><span class="id" type="var">Result</span></span> type to keep track of failing counterexamples. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Module</span> <span class="id" type="var">CheckerPlayground4</span>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">Result</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">Success</span> : <span class="id" type="var">Result</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Failure</span> : ∀ {<span class="id" type="var">A</span>} `{<span class="id" type="keyword">Show</span> <span class="id" type="var">A</span>}, <span class="id" type="var">A</span> → <span class="id" type="var">Result</span>.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">showResult</span> : <span class="id" type="keyword">Show</span> <span class="id" type="var">Result</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">show</span> <span class="id" type="var">r</span> := <span class="id" type="keyword">match</span> <span class="id" type="var">r</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Success</span> ⇒ "Success"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Failure</span> <span class="id" type="var">A</span> <span class="id" type="var">showA</span> <span class="id" type="var">a</span> ⇒ "Failure: " ++ <span class="id" type="var">show</span> <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">Checker</span> := <span class="id" type="var">G</span> <span class="id" type="var">Result</span>.<br/>

<br/>
<span class="id" type="keyword">Class</span> <span class="id" type="var">Checkable</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> : <span class="id" type="var">A</span> → <span class="id" type="var">Checker</span><br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">showUnit</span> : <span class="id" type="keyword">Show</span> <span class="id" type="var">unit</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">show</span> <span class="id" type="var">u</span> := "tt"<br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
The failure cases in the <span class="inlinecode"><span class="id" type="var">bool</span></span> and <span class="inlinecode"><span class="id" type="var">Dec</span></span> checkers don't need to
    record anything except the <span class="inlinecode"><span class="id" type="var">Failure</span></span>, so we put <span class="inlinecode"><span class="id" type="var">tt</span></span> (the sole
    value of type <span class="inlinecode"><span class="id" type="var">unit</span></span>) as the "failure reason." 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">checkableBool</span> : <span class="id" type="var">Checkable</span> <span class="id" type="var">bool</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> <span class="id" type="var">b</span> := <span class="id" type="keyword">if</span> <span class="id" type="var">b</span> <span class="id" type="keyword">then</span> <span class="id" type="var">ret</span> <span class="id" type="var">Success</span> <span class="id" type="keyword">else</span> <span class="id" type="var">ret</span> (<span class="id" type="var">Failure</span> <span class="id" type="var">tt</span>)<br/>
&nbsp;&nbsp;}.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">checkableDec</span> `{<span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>} `{<span class="id" type="var">Dec</span> <span class="id" type="var">P</span>} : <span class="id" type="var">Checkable</span> <span class="id" type="var">P</span> :=<br/>
&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">checker</span> <span class="id" type="var">p</span> := <span class="id" type="keyword">if</span> <span class="id" type="var">P</span>? <span class="id" type="keyword">then</span> <span class="id" type="var">ret</span> <span class="id" type="var">Success</span> <span class="id" type="keyword">else</span> <span class="id" type="var">ret</span> (<span class="id" type="var">Failure</span> <span class="id" type="var">tt</span>)<br/>
&nbsp;&nbsp;}.<br/>
</div>

<div class="doc">
The interesting case is the <span class="inlinecode"><span class="id" type="var">forAll</span></span> combinator.  Here, we <i>do</i>
    have some interesting information to record in the failure case &mdash;
    namely, the argument that caused the failure. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">forAll</span> {<span class="id" type="var">A</span> <span class="id" type="var">B</span> : <span class="id" type="keyword">Type</span>} `{<span class="id" type="keyword">Show</span> <span class="id" type="var">A</span>} `{<span class="id" type="var">Checkable</span> <span class="id" type="var">B</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span> : <span class="id" type="var">G</span> <span class="id" type="var">A</span>) (<span class="id" type="var">f</span> : <span class="id" type="var">A</span> → <span class="id" type="var">B</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">a</span> &lt;- <span class="id" type="var">g</span> ;;<br/>
&nbsp;&nbsp;<span class="id" type="var">r</span> &lt;- <span class="id" type="var">checker</span> (<span class="id" type="var">f</span> <span class="id" type="var">a</span>) ;;<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">r</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Success</span> ⇒ <span class="id" type="var">ret</span> <span class="id" type="var">Success</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Failure</span> <span class="id" type="var">B</span> <span class="id" type="var">showB</span> <span class="id" type="var">b</span> ⇒ <span class="id" type="var">ret</span> (<span class="id" type="var">Failure</span> (<span class="id" type="var">a</span>,<span class="id" type="var">b</span>))<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
Note that, rather than just returning <span class="inlinecode"><span class="id" type="var">Failure</span></span> <span class="inlinecode"><span class="id" type="var">a</span></span>, we package up
    <span class="inlinecode"><span class="id" type="var">a</span></span> together with <span class="inlinecode"><span class="id" type="var">b</span></span>, which is the "reason" for the failure of <span class="inlinecode"><span class="id" type="var">f</span></span>
    <span class="inlinecode"><span class="id" type="var">a</span></span>.  This allows us to write several <span class="inlinecode"><span class="id" type="var">forAll</span></span>s in sequence and
    capture all of their results in a nested tuple. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">CheckerPlayground4</span>.<br/>

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">CheckerPlayground4.forAll</span> (<span class="id" type="var">genTreeSized'</span> 3 (<span class="id" type="var">choose</span>(0,3))) <span class="id" type="var">faultyMirrorP</span>).<br/>
</div>

<div class="doc">
<pre>
      [Failure: (Node (2) (Node (3) (Node (2) (Leaf) (Leaf)) (Leaf)) 
                          (Node (0) (Node (2) (Leaf) (Leaf)) (Leaf)), tt), 
      Success, 
      Failure: (Node (2) (Node (3) (Node (3) (Leaf) (Leaf)) (Leaf)) (Leaf), tt), 
      Success, Success, Success, 
      Failure: (Node (1) (Node (2) (Leaf) (Node (3) (Leaf) (Leaf))) 
                         (Node (0) (Leaf) (Node (1) (Leaf) (Leaf))), tt), 
      Success, 
      Failure: (Node (3) (Node (0) (Node (0) (Leaf) (Leaf)) (Leaf)) 
                         (Node (0) (Leaf) (Node (2) (Leaf) (Leaf))), tt), 
      Failure: (Node (2) (Node (2) (Node (0) (Leaf) (Leaf)) (Leaf)) 
                         (Node (1) (Leaf) (Node (2) (Leaf) (Leaf))), tt), 
      Success]
</pre>

<div class="paragraph"> </div>

 The bug is found several times and actual counterexamples are
    reported: nice!  (Indeed, what we've seen here basically what the
    <span class="inlinecode"><span class="id" type="var">QuickChick</span></span> command does; the only difference is that, instead of
    running a fixed number of tests and returning their results in a
    list, it runs tests only until the first counterexample is found.)

<div class="paragraph"> </div>

    However, these counterexamples leave something to be desired &mdash;
    they are all much larger than is really needed to illustrate the
    bad behavior of <span class="inlinecode"><span class="id" type="var">faultyMirrorP</span></span>.  This is where shrinking comes
    in... 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;BCP&nbsp;STOPPED&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab57"></a><h1 class="section">Shrinking</h1>

<div class="paragraph"> </div>

 Shrinking, also known as delta debugging, is a process that, given
    a counterexample to some property, searches (greedily) for smaller
    counterexamples.  Given a shrinking function <span class="inlinecode"><span class="id" type="var">s</span></span> of type <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">list</span></span>
    <span class="inlinecode"><span class="id" type="var">A</span></span> and a counterexample <span class="inlinecode"><span class="id" type="var">x</span></span> of type <span class="inlinecode"><span class="id" type="var">A</span></span> that is known to falsify
    some property <span class="inlinecode"><span class="id" type="var">p</span></span>, QuickChick (lazily) tries <span class="inlinecode"><span class="id" type="var">p</span></span> on all members of
    <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> until it finds another counterexample; then it repeats this
    process.

<div class="paragraph"> </div>

    This greedy algorithm can only work if all elements of <span class="inlinecode"><span class="id" type="var">s</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span> are
    strictly "smaller" that <span class="inlinecode"><span class="id" type="var">x</span></span> for all <span class="inlinecode"><span class="id" type="var">x</span></span>. Most of the time, a
    shrinking function for some type only returns elements that are
    "one step" smaller. For example, consider the default shrinking
    function for lists provided by QuickChick. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">shrinkList</span>.<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       shrinkList = 
         fix shrinkList (A : Type) (shr : A -&gt; seq A) (l : seq A) {struct l} :
           seq (seq A) :=
           match l with
           | [::] =&gt; [::]
           | x :: xs =&gt;
               ((xs :: List.map (fun xs' : seq A =&gt; x :: xs') (shrinkList A shr xs))%SEQ ++
                List.map (fun x' : A =&gt; (x' :: xs)%SEQ) (shr x))%list
           end
              : forall A : Type, (A -&gt; seq A) -&gt; seq A -&gt; seq (seq A)
</pre>

<div class="paragraph"> </div>

 An empty list can not be shrunk - there is no smaller list.  A
    cons cell can be shrunk in three ways: by returning the tail of
    the list, by shrinking the tail of the list and consing the head,
    or by shrinking the head and consing its tail. By induction, this
    process can generate all smaller lists.

<div class="paragraph"> </div>

    Writing a shrinking instance for trees is equally straightforward:
    we don't shrink <span class="inlinecode"><span class="id" type="var">Leaf</span></span>s while for <span class="inlinecode"><span class="id" type="var">Node</span></span>s we can return the left
    or right subtrees, shrink the payload or one of the subtrees.
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">list</span>.<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">shrinkTree</span> {<span class="id" type="var">A</span>} (<span class="id" type="var">s</span> : <span class="id" type="var">A</span> → <span class="id" type="var">list</span> <span class="id" type="var">A</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) : <span class="id" type="var">list</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒ [<span class="id" type="var">l</span>] ++ [<span class="id" type="var">r</span>] ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x'</span> ⇒ <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span>) (<span class="id" type="var">s</span> <span class="id" type="var">x</span>) ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">l'</span> ⇒ <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">l'</span> <span class="id" type="var">r</span>) (<span class="id" type="var">shrinkTree</span> <span class="id" type="var">s</span> <span class="id" type="var">l</span>) ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">r'</span> ⇒ <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">r'</span>) (<span class="id" type="var">shrinkTree</span> <span class="id" type="var">s</span> <span class="id" type="var">r</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
<div style="background-color:lightgray; color:red; margin:10px; padding:10px; "> Explain it 
</div>  Armed with <span class="inlinecode"><span class="id" type="var">shrinkTree</span></span>, we use the <span class="inlinecode"><span class="id" type="var">forAllShrink</span></span> property
    combinator that takes an additional argument, a shrinker 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;(forAllShrink&nbsp;(genTreeSized'&nbsp;5&nbsp;(choose&nbsp;(0,5)))&nbsp;(shrinkTree&nbsp;shrink)&nbsp;faultyMirrorP).&nbsp;*)</span><br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       Node (0) (Leaf) (Node (0) (Leaf) (Leaf))

       *** Failed! After 1 tests and 8 shrinks 
</pre>

<div class="paragraph"> </div>

 We now got a much simpler counterexample (in fact, this is one of
    the two minimal ones) and can tell that the real problem occurs
    when the subtrees of a <span class="inlinecode"><span class="id" type="var">Node</span></span> are different. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Simple&nbsp;exercise&nbsp;:&nbsp;Ternary&nbsp;Trees&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span> :=<br/>
| <span class="id" type="var">TLeaf</span> : <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span><br/>
| <span class="id" type="var">TNode</span> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">A</span> → <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span> → <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span> → <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span> → <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="var">Arguments</span> <span class="id" type="var">TLeaf</span> {<span class="id" type="var">A</span>}.<br/>
<span class="id" type="var">Arguments</span> <span class="id" type="var">TNode</span> {<span class="id" type="var">A</span>} <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Mirror&nbsp;for&nbsp;ternary&nbsp;trees&nbsp;*)</span><br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">tern_mirror</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">t</span> : <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span>) : <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TLeaf</span> ⇒ <span class="id" type="var">TLeaf</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TNode</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">m</span> <span class="id" type="var">r</span> ⇒ <span class="id" type="var">TNode</span> <span class="id" type="var">x</span> (<span class="id" type="var">tern_mirror</span> <span class="id" type="var">r</span>) <span class="id" type="var">m</span> (<span class="id" type="var">tern_mirror</span> <span class="id" type="var">l</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Option&nbsp;1:&nbsp;In-order,&nbsp;correct&nbsp;spec,&nbsp;faulty&nbsp;mirror&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Option&nbsp;2:&nbsp;(I&nbsp;like&nbsp;this&nbsp;more)&nbsp;Pre-order,&nbsp;incorrect&nbsp;spec,&nbsp;fix&nbsp;traversal&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;In-order&nbsp;traversal&nbsp;of&nbsp;ternary&nbsp;tree&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">tern_to_list</span> {<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>} (<span class="id" type="var">t</span> : <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span>) : <span class="id" type="var">list</span> <span class="id" type="var">A</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">fix</span> <span class="id" type="var">aux</span> <span class="id" type="var">t</span> <span class="id" type="var">def</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TLeaf</span> ⇒ <span class="id" type="var">def</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">TNode</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">m</span> <span class="id" type="var">r</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">aux</span> <span class="id" type="var">l</span> [] ++ <span class="id" type="var">aux</span> <span class="id" type="var">m</span> [<span class="id" type="var">x</span>] ++ <span class="id" type="var">aux</span> <span class="id" type="var">r</span> []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;<span class="id" type="var">aux</span> <span class="id" type="var">t</span> [].<br/>

<br/>
<span class="comment">(*&nbsp;Equality&nbsp;for&nbsp;ternary&nbsp;trees&nbsp;*)</span><br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">eq_dec_ternary</span> <span class="id" type="var">A</span> (<span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">TernaryTree</span> <span class="id" type="var">A</span>) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`{<span class="id" type="var">D</span> : ∀ <span class="id" type="var">x</span> <span class="id" type="var">y</span> : <span class="id" type="var">A</span>, <span class="id" type="var">Dec</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>)} : <span class="id" type="var">Dec</span> (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
<span class="id" type="var">constructor</span>; <span class="id" type="tactic">unfold</span> <span class="id" type="var">ssrbool.decidable</span>.<br/>
<span class="id" type="var">decide</span> <span class="id" type="var">equality</span>.<br/>
<span class="id" type="tactic">destruct</span> (<span class="id" type="var">D</span> <span class="id" type="var">a</span> <span class="id" type="var">a<sub>0</sub></span>); <span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Leo:&nbsp;They've&nbsp;alredy&nbsp;written&nbsp;enough&nbsp;show&nbsp;functions&nbsp;haven't&nbsp;they?&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;EX&nbsp;1:&nbsp;Derive&nbsp;a&nbsp;Show&nbsp;instance&nbsp;for&nbsp;Ternary&nbsp;Trees.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;Leo:&nbsp;TODO:&nbsp;Monad&nbsp;notation&nbsp;*)</span><br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">QcDoNotation</span>.<br/>
<span class="comment">(*&nbsp;EX&nbsp;2:&nbsp;Write&nbsp;a&nbsp;generator&nbsp;for&nbsp;ternary&nbsp;trees&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;This&nbsp;should&nbsp;generate&nbsp;a&nbsp;bunch&nbsp;of&nbsp;nat&nbsp;ternary&nbsp;trees&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Sample&nbsp;(@genTernTreeSized&nbsp;nat&nbsp;3&nbsp;arbitrary).&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;EX&nbsp;3:&nbsp;Write&nbsp;a&nbsp;shrinker&nbsp;for&nbsp;ternary&nbsp;trees&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;Converting&nbsp;a&nbsp;ternary&nbsp;tree&nbsp;to&nbsp;a&nbsp;list&nbsp;and&nbsp;reversing&nbsp;it&nbsp;should&nbsp;yield&nbsp;the&nbsp;same&nbsp;<br/>
&nbsp;&nbsp;&nbsp;list&nbsp;as&nbsp;mirroring&nbsp;the&nbsp;tree&nbsp;and&nbsp;then&nbsp;converting&nbsp;it&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">tern_mirror_reverse</span> (<span class="id" type="var">t</span> : <span class="id" type="var">TernaryTree</span> <span class="id" type="var">nat</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="var">tern_to_list</span> (<span class="id" type="var">tern_mirror</span> <span class="id" type="var">t</span>) = <span class="id" type="var">List.rev</span> (<span class="id" type="var">tern_to_list</span> <span class="id" type="var">t</span>) ?.<br/>

<br/>
<span class="comment">(*&nbsp;EX&nbsp;4&nbsp;:&nbsp;Using&nbsp;genTernTreeSized&nbsp;and&nbsp;shrinkTernTree&nbsp;find&nbsp;any&nbsp;bugs&nbsp;in&nbsp;tern_mirror&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab58"></a><h1 class="section">  </h1>

</div>
<div class="code code-space">

<br/>
</div>

<div class="doc">
<a name="lab59"></a><h1 class="section">Putting it all Together</h1>

<div class="paragraph"> </div>

 <div style="background-color:lightgray; color:red; margin:10px; padding:10px; "> typeclass magic to hide forAll (requires introducing Gen and GenSized) 
</div>  QuickChick, just like QuickCheck, provides an <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span>
    typeclass parameterized over some type <span class="inlinecode"><span class="id" type="var">A</span></span> with two objects:
    <span class="inlinecode"><span class="id" type="var">arbitrary</span></span> and <span class="inlinecode"><span class="id" type="var">shrink</span></span>.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="var">arbitrary</span></span> object is a generator for elements of type <span class="inlinecode"><span class="id" type="var">A</span></span>. If
    we were to encode an <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span> instance for trees we would like
    to use <span class="inlinecode"><span class="id" type="var">genTreeSized'</span></span>; however that generator takes an additional
    size argument.  The <span class="inlinecode"><span class="id" type="var">G</span></span> monad will provide that argument through
    the combinator <span class="inlinecode"><span class="id" type="var">sized</span></span>.
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">sized</span>.<br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
        sized : (nat -&gt; G ?A) -&gt; G ?A 
</pre>

<div class="paragraph"> </div>

 <span class="inlinecode"><span class="id" type="var">sized</span></span> receives a function that given a number produces a
    generator, just like <span class="inlinecode"><span class="id" type="var">genTreeSized'</span></span>, and returns a generator that
    uses the size information inside the <span class="inlinecode"><span class="id" type="var">G</span></span> monad.

<div class="paragraph"> </div>

    The <span class="inlinecode"><span class="id" type="var">shrink</span></span> function is simply a shrinker like <span class="inlinecode"><span class="id" type="var">shrinkTree</span></span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">genTree</span> {<span class="id" type="var">A</span>} `{<span class="id" type="var">Gen</span> <span class="id" type="var">A</span>} : <span class="id" type="var">GenSized</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) := <br/>
&nbsp;&nbsp;{| <span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span> := <span class="id" type="var">genTreeSized</span> <span class="id" type="var">n</span> <span class="id" type="var">arbitrary</span> |}.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">shrTree</span> {<span class="id" type="var">A</span>} `{<span class="id" type="var">Shrink</span> <span class="id" type="var">A</span>} : <span class="id" type="var">Shrink</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) := <br/>
&nbsp;&nbsp;{| <span class="id" type="var">shrink</span> <span class="id" type="var">x</span> := <span class="id" type="var">shrinkTree</span> <span class="id" type="var">shrink</span> <span class="id" type="var">x</span> |}.<br/>
</div>

<div class="doc">
With this <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span> instance we can once again use the toplevel
    <span class="inlinecode"><span class="id" type="var">QuickChick</span></span> command with just the property.  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;faultyMirrorP.&nbsp;*)</span><br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">QuickChick</span></span> internally calls the function <span class="inlinecode"><span class="id" type="var">quickCheck</span></span> with type
    <span class="inlinecode">∀</span> <span class="inlinecode"><span class="id" type="var">prop</span>.</span> <span class="inlinecode"><span class="id" type="var">Checkable</span></span> <span class="inlinecode"><span class="id" type="var">prop</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">prop</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Result</span></span>. But what <i>is</i>
    <span class="inlinecode"><span class="id" type="var">Checkable</span></span>? It is easy to see how a boolean is <span class="inlinecode"><span class="id" type="var">Checkable</span></span>; we
    can always tell if it is true or not and then return a <span class="inlinecode"><span class="id" type="var">Result</span></span>,
    <span class="inlinecode"><span class="id" type="var">Success</span></span>/<span class="inlinecode"><span class="id" type="var">Failure</span></span> as appropriate.

<div class="paragraph"> </div>

    To see how executable properties are <span class="inlinecode"><span class="id" type="var">Checkable</span></span>, consider a
    single argument function <span class="inlinecode"><span class="id" type="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">Bool</span></span> that returns a
    boolean. If we know that <span class="inlinecode"><span class="id" type="var">A</span></span> has <span class="inlinecode"><span class="id" type="keyword">Show</span></span> and <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span> instances,
    we can just call <span class="inlinecode"><span class="id" type="var">forAllShrink</span></span> with <span class="inlinecode"><span class="id" type="var">arbitrary</span></span> and
    <span class="inlinecode"><span class="id" type="var">shrink</span></span>. Going a step further, the result type doesn't really
    need to be <span class="inlinecode"><span class="id" type="var">Bool</span></span>, it can be a <span class="inlinecode"><span class="id" type="var">Checkable</span></span>! Thus, we can provide a
    <span class="inlinecode"><span class="id" type="var">Checkable</span></span> instance for arbitrary functions.
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">testFun</span>.<br/>

<br/>
<span class="comment">(*&nbsp;EX&nbsp;5&nbsp;:&nbsp;Add&nbsp;typeclass&nbsp;instances&nbsp;for&nbsp;GenSized&nbsp;and&nbsp;Shrink&nbsp;so&nbsp;that&nbsp;you&nbsp;can<br/>
QuickChick&nbsp;tern_mirror_spec&nbsp;directly&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;tern_mirror_spec.&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;TODO:&nbsp;Move&nbsp;derivation&nbsp;stuff&nbsp;here?&nbsp;*)</span><br/>
</div>

<div class="doc">
<a name="lab60"></a><h1 class="section">Avoiding Work  :)</h1>

<div class="paragraph"> </div>

 While a lot of time putting a bit of time and effort in a
    generator and a shrinker, the examples shown here are fairly
    straightforward. After writing a couple of <span class="inlinecode"><span class="id" type="keyword">Show</span></span> and <span class="inlinecode"><span class="id" type="var">Arbitrary</span></span>
    instances, it can get tedious and boring. That is precisely why
    <span class="inlinecode"><span class="id" type="var">QuickChick</span></span> provides some automation in deriving such instances
    for <i>plain</i> datatypes automatically. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="var">Arbitrary</span> <span class="id" type="keyword">for</span> <span class="id" type="var">Tree</span>.<br/>
<span class="comment">(*&nbsp;genSTree&nbsp;is&nbsp;defined&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;shrTree0&nbsp;is&nbsp;defined&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">genSTree</span>.<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">shrTree0</span>.<br/>

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="keyword">Show</span> <span class="id" type="keyword">for</span> <span class="id" type="var">Tree</span>.<br/>
<span class="comment">(*&nbsp;showTree0&nbsp;is&nbsp;defined&nbsp;*)</span><br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">showTree0</span>.<br/>
</div>

<div class="doc">
<a name="lab61"></a><h1 class="section">Collecting Statistics</h1>

<div class="paragraph"> </div>

 Earlier in this tutorial we claimed that <span class="inlinecode"><span class="id" type="var">genTreeSized</span></span> produced
    "too many" <span class="inlinecode"><span class="id" type="var">Leaf</span></span>s. But how can we justify that? Just looking at
    the result of <span class="inlinecode"><span class="id" type="var">Sample</span></span> gives us an idea that something is going
    wrong but just observing a handful of samples cannot realistically
    provide statistical guarantees. That is where <span class="inlinecode"><span class="id" type="var">collect</span></span>, another
    property combinator, comes in. In Haskell notation, <span class="inlinecode"><span class="id" type="var">collect</span></span>
    would have the type <span class="inlinecode"><span class="id" type="var">collect</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Show</span></span> <span class="inlinecode"><span class="id" type="var">A</span>,</span> <span class="inlinecode"><span class="id" type="var">Checkable</span></span> <span class="inlinecode"><span class="id" type="var">prop</span></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" type="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">prop</span></span>
    <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" type="var">prop</span></span>; it takes some value of type <span class="inlinecode"><span class="id" type="var">A</span></span> that can be shown and a
    property, and returns the property itself. Whenever the resulting
    property is exercised, the <span class="inlinecode"><span class="id" type="var">A</span></span> object is captured and statistics
    are collected.

<div class="paragraph"> </div>

    For example, consider a <span class="inlinecode"><span class="id" type="var">size</span></span> function on <span class="inlinecode"><span class="id" type="var">Tree</span></span>s.
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">size</span> {<span class="id" type="var">A</span>} (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">A</span>) : <span class="id" type="var">nat</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ <span class="id" type="var">O</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">_</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒ 1 + <span class="id" type="var">size</span> <span class="id" type="var">l</span> + <span class="id" type="var">size</span> <span class="id" type="var">r</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
If we were to write a dummy property to check our generators and
    measure the size of generated trees, we could use <span class="inlinecode"><span class="id" type="var">treeProp</span></span>
    below. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">treeProp</span> (<span class="id" type="var">g</span> : <span class="id" type="var">nat</span> → <span class="id" type="var">G</span> <span class="id" type="var">nat</span> → <span class="id" type="var">G</span> (<span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>)) <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">g</span> <span class="id" type="var">n</span> (<span class="id" type="var">choose</span> (0,<span class="id" type="var">n</span>))) (<span class="id" type="keyword">fun</span> <span class="id" type="var">t</span> ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="var">collect</span> (<span class="id" type="var">size</span> <span class="id" type="var">t</span>) <span class="id" type="var">true</span>).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;(treeProp&nbsp;genTreeSized&nbsp;&nbsp;5).&nbsp;*)</span><br/>
</div>

<div class="doc">
<pre>
      ===&gt; 
       4947 : 0
       1258 : 1
       673 : 2
       464 : 6
       427 : 5
       393 : 3
       361 : 7
       302 : 4
       296 : 8
       220 : 9
       181 : 10
       127 : 11
       104 : 12
       83 : 13
       64 : 14
       32 : 15
       25 : 16
       16 : 17
       13 : 18
       6 : 19
       5 : 20
       2 : 21
       1 : 23
       +++ OK, passed 10000 tests
</pre>

<div class="paragraph"> </div>

 We see that 62.5% of the tests are either <span class="inlinecode"><span class="id" type="var">Leaf</span></span>s or empty
    <span class="inlinecode"><span class="id" type="var">Nodes</span></span>, while too few tests have larger sizes. Compare that with
    <span class="inlinecode"><span class="id" type="var">genTreeSized'</span></span> below.  
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;(treeProp&nbsp;genTreeSized'&nbsp;5).&nbsp;*)</span></div>

<div class="doc">
<pre>
      ===&gt; 
       1624 : 0
       571 : 10
       564 : 12
       562 : 11
       559 : 9
       545 : 8
       539 : 14
       534 : 13
       487 : 7
       487 : 15
       437 : 16
       413 : 6
       390 : 17
       337 : 5
       334 : 1
       332 : 18
       286 : 19
       185 : 4
       179 : 20
       179 : 2
       138 : 21
       132 : 3
       87 : 22
       62 : 23
       19 : 24
       10 : 25
       6 : 26
       2 : 27
       +++ OK, passed 10000 tests
</pre>

<div class="paragraph"> </div>

 A lot fewer terms have small sizes, allowing us to explore larger terms
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Dealing&nbsp;with&nbsp;preconditions&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Consider&nbsp;inserting&nbsp;in&nbsp;a&nbsp;sorted&nbsp;list&nbsp;*)</span><br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">insert</span> (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">nat</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| [] ⇒ [<span class="id" type="var">x</span>] <br/>
&nbsp;&nbsp;| <span class="id" type="var">y</span>::<span class="id" type="var">ys</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">x</span> &lt;=? <span class="id" type="var">y</span> <span class="id" type="keyword">then</span> <span class="id" type="var">x</span> :: <span class="id" type="var">l</span> <span class="id" type="keyword">else</span> <span class="id" type="var">y</span> :: <span class="id" type="var">insert</span> <span class="id" type="var">x</span> <span class="id" type="var">ys</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Leo:&nbsp;Scoping/associativity&nbsp;between&nbsp;&lt;?&nbsp;/&nbsp;&amp;&amp;.&nbsp;Maybe&nbsp;just&nbsp;andb?&nbsp;*)</span><br/>
<span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">bool</span>.<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">sorted</span> (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">nat</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">x</span>::<span class="id" type="var">xs</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">xs</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">y</span> :: <span class="id" type="var">ys</span> ⇒ (<span class="id" type="var">x</span> &lt;=? <span class="id" type="var">y</span>) &amp;&amp; (<span class="id" type="var">sorted</span> <span class="id" type="var">xs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;We&nbsp;could&nbsp;test&nbsp;insert&nbsp;using&nbsp;the&nbsp;following&nbsp;{\em&nbsp;conditional}&nbsp;property:&nbsp;*)</span><br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">QcNotation</span>. <span class="comment">(*&nbsp;Do&nbsp;we&nbsp;want&nbsp;that?&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">insert_spec</span> (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">sorted</span> <span class="id" type="var">l</span> ==&gt; <span class="id" type="var">sorted</span> (<span class="id" type="var">insert</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;insert_spec.&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;But&nbsp;how&nbsp;do&nbsp;we&nbsp;know&nbsp;if&nbsp;we&nbsp;have&nbsp;tested&nbsp;{\em&nbsp;enough}?&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">insert_spec'</span> (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">l</span> : <span class="id" type="var">list</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">collect</span> (<span class="id" type="var">List.length</span> <span class="id" type="var">l</span>) (<span class="id" type="var">insert_spec</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;insert_spec'.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;3.5k&nbsp;times&nbsp;<span class="inlinecode"></span>&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;3.5k&nbsp;times&nbsp;singletons&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;2k&nbsp;times&nbsp;length&nbsp;2&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;clearly,&nbsp;not&nbsp;good&nbsp;enough&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;For&nbsp;properties&nbsp;with&nbsp;preconditions,&nbsp;we&nbsp;write&nbsp;custom&nbsp;generators&nbsp;that&nbsp;satisfy&nbsp;the&nbsp;property&nbsp;directly!&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Let's&nbsp;generate&nbsp;sorted&nbsp;lists&nbsp;with&nbsp;elements&nbsp;between&nbsp;low&nbsp;and&nbsp;high&nbsp;*)</span><br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">genSortedList</span> (<span class="id" type="var">low</span> <span class="id" type="var">high</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">size</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">G</span> (<span class="id" type="var">list</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">size</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">O</span> ⇒ <span class="id" type="var">returnGen</span> []<br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">size'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">high</span> &lt;? <span class="id" type="var">low</span> <span class="id" type="keyword">then</span> <span class="id" type="var">returnGen</span> []<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">freq</span> [ (1, <span class="id" type="var">returnGen</span> []) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;; (<span class="id" type="var">size</span>, <span class="id" type="tactic">do</span>! <span class="id" type="var">x</span>  &lt;- <span class="id" type="var">choose</span> (<span class="id" type="var">low</span>, <span class="id" type="var">high</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">do</span>! <span class="id" type="var">xs</span> &lt;- <span class="id" type="var">genSortedList</span> <span class="id" type="var">x</span> <span class="id" type="var">high</span> <span class="id" type="var">size'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">returnGen</span> (<span class="id" type="var">x</span> :: <span class="id" type="var">xs</span>)) ]<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="var">Sample</span> (<span class="id" type="var">genSortedList</span> 0 10 10).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">insert_spec_sorted</span> (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrink</span> (<span class="id" type="var">genSortedList</span> 0 10 10) <span class="id" type="var">shrink</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">l</span> ⇒ <span class="id" type="var">insert_spec'</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;insert_spec_sorted.&nbsp;*)</span><br/>
</div>

<div class="doc">
Much better! 
<div class="paragraph"> </div>

 But are we done yet? 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;EX&nbsp;(hard)<br/>
&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;Using&nbsp;"collect",&nbsp;figure&nbsp;out&nbsp;whether&nbsp;generating&nbsp;a&nbsp;sorted&nbsp;list&nbsp;of&nbsp;numbers<br/>
&nbsp;&nbsp;&nbsp;between&nbsp;0&nbsp;and&nbsp;5&nbsp;is&nbsp;uniform&nbsp;in&nbsp;the&nbsp;frequencies&nbsp;of&nbsp;the&nbsp;numbers&nbsp;generated.<br/>
<br/>
&nbsp;&nbsp;&nbsp;Why?&nbsp;Write&nbsp;a&nbsp;different&nbsp;generator&nbsp;genSortedList'&nbsp;that&nbsp;achieves&nbsp;a&nbsp;more&nbsp;uniform<br/>
&nbsp;&nbsp;&nbsp;distribution,&nbsp;preserving&nbsp;the&nbsp;uniformity&nbsp;in&nbsp;the&nbsp;lengths<br/>
&nbsp;&nbsp;&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;EX&nbsp;:&nbsp;Binary&nbsp;Search&nbsp;Trees&nbsp;*)</span><br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">isBST</span> (<span class="id" type="var">low</span> <span class="id" type="var">high</span>: <span class="id" type="var">nat</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) := <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒ (<span class="id" type="var">low</span> &lt;? <span class="id" type="var">x</span>) &amp;&amp; (<span class="id" type="var">x</span> &lt;? <span class="id" type="var">high</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp; (<span class="id" type="var">isBST</span> <span class="id" type="var">low</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>) &amp;&amp; (<span class="id" type="var">isBST</span> <span class="id" type="var">x</span> <span class="id" type="var">high</span> <span class="id" type="var">r</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Give&nbsp;them&nbsp;insert&nbsp;or&nbsp;have&nbsp;them&nbsp;write&nbsp;it?&nbsp;*)</span><br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">insertBST</span> (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">Leaf</span> <span class="id" type="var">Leaf</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">x</span> &lt;? <span class="id" type="var">x'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> (<span class="id" type="var">insertBST</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>) <span class="id" type="var">r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> <span class="id" type="var">l</span> (<span class="id" type="var">insertBST</span> <span class="id" type="var">x</span> <span class="id" type="var">r</span>)<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">insertBST_spec</span> (<span class="id" type="var">low</span> <span class="id" type="var">high</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">low</span> &lt;? <span class="id" type="var">x</span>) ==&gt; (<span class="id" type="var">x</span> &lt;? <span class="id" type="var">high</span>) ==&gt; (<span class="id" type="var">isBST</span> <span class="id" type="var">low</span> <span class="id" type="var">high</span> <span class="id" type="var">t</span>) ==&gt; <br/>
&nbsp;&nbsp;<span class="id" type="var">isBST</span> <span class="id" type="var">low</span> <span class="id" type="var">high</span> (<span class="id" type="var">insertBST</span> <span class="id" type="var">x</span> <span class="id" type="var">t</span>).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;insertBST_spec.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Too&nbsp;much&nbsp;wasted&nbsp;effort:&nbsp;16&nbsp;tests&nbsp;-&nbsp;270&nbsp;discards!&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">insertBST'</span> (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| <span class="id" type="var">Leaf</span> ⇒ <span class="id" type="var">Node</span> <span class="id" type="var">x</span> <span class="id" type="var">Leaf</span> <span class="id" type="var">Leaf</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> <span class="id" type="var">l</span> <span class="id" type="var">r</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">x</span> &lt;? <span class="id" type="var">x'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> (<span class="id" type="var">insertBST'</span> <span class="id" type="var">x</span> <span class="id" type="var">l</span>) <span class="id" type="var">r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="keyword">if</span> <span class="id" type="var">x'</span> &lt;? <span class="id" type="var">x</span> <span class="id" type="keyword">then</span> <span class="id" type="var">Node</span> <span class="id" type="var">x'</span> <span class="id" type="var">l</span> (<span class="id" type="var">insertBST'</span> <span class="id" type="var">x</span> <span class="id" type="var">r</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">insertBST_spec'</span> (<span class="id" type="var">low</span> <span class="id" type="var">high</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">x</span> : <span class="id" type="var">nat</span>) (<span class="id" type="var">t</span> : <span class="id" type="var">Tree</span> <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;(<span class="id" type="var">low</span> &lt;? <span class="id" type="var">x</span>) ==&gt; (<span class="id" type="var">x</span> &lt;? <span class="id" type="var">high</span>) ==&gt; (<span class="id" type="var">isBST</span> <span class="id" type="var">low</span> <span class="id" type="var">high</span> <span class="id" type="var">t</span>) ==&gt; <br/>
&nbsp;&nbsp;<span class="id" type="var">isBST</span> <span class="id" type="var">low</span> <span class="id" type="var">high</span> (<span class="id" type="var">insertBST'</span> <span class="id" type="var">x</span> <span class="id" type="var">t</span>).<br/>

<br/>
<span class="comment">(*&nbsp;QuickChick&nbsp;insertBST_spec'.&nbsp;*)</span><br/>
<span class="comment">(*&nbsp;Fixing&nbsp;the&nbsp;bug&nbsp;==&gt;&nbsp;Gave&nbsp;up!&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;EX&nbsp;:&nbsp;Binary&nbsp;search&nbsp;tree&nbsp;generator&nbsp;<br/>
Write&nbsp;a&nbsp;generator&nbsp;that&nbsp;produces&nbsp;binary&nbsp;search&nbsp;trees&nbsp;directly,&nbsp;so&nbsp;that&nbsp;<br/>
you&nbsp;run&nbsp;10000&nbsp;tests&nbsp;with&nbsp;0&nbsp;discards&nbsp;*)</span></div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>