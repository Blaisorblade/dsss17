<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>CompilerTestAnswers</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
<ul id='menu'>
   <a href='index.html'><li class='section_name'>VMinus Development</li></a>
   <a href='toc.html'><li>Table of Contents</li></a>
   <a href='coqindex.html'><li>Index</li></a>
   <a href='deps.html'><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">CompilerTestAnswers</h1>

<div class="code code-tight">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">List</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">ListNotations</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">String</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Arith</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">QuickChick.QuickChick</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">QcDefaultNotation</span>. <span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">qc_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Stmon</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Vminus</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Atom</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.CFG</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.ListCFG</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Imp</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Compiler</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.ImpGen</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.VminusGen</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.OpSemGen</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.CompilerTest</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.VminusOpSem</span>. <span class="comment">(*&nbsp;More&nbsp;refactoring&nbsp;work&nbsp;to&nbsp;do&nbsp;*)</span><br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">V.Opsem</span>.<br/>

<br/>
<span class="comment">(**!&nbsp;Section&nbsp;test_compile_bexp&nbsp;extends&nbsp;compiler&nbsp;*)</span><br/>

<br/>
<span class="comment">(*&nbsp;Fatal&nbsp;error&nbsp;with&nbsp;stack&nbsp;overflow&nbsp;<br/>
Definition&nbsp;comp_bop_correct_checker:&nbsp;Checker&nbsp;:=<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(a<sub>1</sub>:&nbsp;aexp)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(a<sub>2</sub>:&nbsp;aexp)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(binop:&nbsp;bop)&nbsp;=&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;collect&nbsp;(binop,&nbsp;a<sub>1</sub>,&nbsp;a<sub>2</sub>)&nbsp;(comp_correct_checker&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(comp_bop&nbsp;binop&nbsp;(comp_aexp&nbsp;a<sub>1</sub>)&nbsp;(comp_aexp&nbsp;a<sub>2</sub>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fun&nbsp;m&nbsp;=&gt;&nbsp;V.Opsem.bop_denote&nbsp;binop&nbsp;(aeval&nbsp;a<sub>1</sub>&nbsp;m)&nbsp;(aeval&nbsp;a<sub>2</sub>&nbsp;m)))))).<br/>
&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_bop_correct_checker</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a<sub>1</sub></span>: <span class="id" type="var">aexp</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a<sub>2</sub></span>: <span class="id" type="var">aexp</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">binop</span>: <span class="id" type="var">bop</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">collect</span> <span class="id" type="var">binop</span> (<span class="id" type="var">comp_correct_checker</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp_bop</span> <span class="id" type="var">binop</span> (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a<sub>1</sub></span>) (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">V.Opsem.bop_denote</span> <span class="id" type="var">binop</span> (<span class="id" type="var">aeval</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">m</span>) (<span class="id" type="var">aeval</span> <span class="id" type="var">a<sub>2</sub></span> <span class="id" type="var">m</span>)))))).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_bop_correct_checker.&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_bexp_correct_checker</span> : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">b</span>: <span class="id" type="var">bexp</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker</span> (<span class="id" type="var">comp_bexp</span> <span class="id" type="var">b</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="keyword">if</span> (<span class="id" type="var">beval</span> <span class="id" type="var">b</span> <span class="id" type="var">m</span>) <span class="id" type="keyword">then</span> 1 <span class="id" type="keyword">else</span> 0)).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_bexp_correct_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
Exercise: Now write a checker for the following.

<div class="paragraph"> </div>

Lemma comp_store_correct : 
  forall g a v le lr cs st,
  insns_at_pc g (block_entry le) (steval (comp_store a v lr) cs) -&gt;
  st_pc st = (block_entry le) -&gt;
  exists st',
    plus (step g) st st' /\
    st_pc st' = (block_entry lr) /\
    st_mem st' = (Memory.update (st_mem st) v (aeval a (st_mem st))).

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*<br/>
Definition&nbsp;comp_store_correct_checker_inner'<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a&nbsp;:&nbsp;aexp)&nbsp;(v:&nbsp;addr)&nbsp;(lr&nbsp;le:&nbsp;lbl)&nbsp;(cs:&nbsp;list&nbsp;uid)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst:&nbsp;vminus_state)<br/>
&nbsp;&nbsp;:&nbsp;Checker&nbsp;:=<br/>
&nbsp;&nbsp;let&nbsp;st&nbsp;:=&nbsp;V.Opsem.mkst&nbsp;(vst_mem&nbsp;vst)&nbsp;(block_entry&nbsp;le)&nbsp;(vst_loc&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_ppc&nbsp;vst)&nbsp;(vst_ploc&nbsp;vst)&nbsp;in<br/>
&nbsp;&nbsp;let&nbsp;vst&nbsp;:=&nbsp;mk_vminus_state<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_mem&nbsp;vst)&nbsp;(vst_mem_dom&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(block_entry&nbsp;le)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_loc&nbsp;vst)&nbsp;(vst_loc_dom&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_ppc&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_ploc&nbsp;vst)&nbsp;(vst_ploc_dom&nbsp;vst)&nbsp;in<br/>
&nbsp;&nbsp;let&nbsp;'(g,&nbsp;end_pc)&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrap_code_in_cfg&nbsp;(block_entry&nbsp;le)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Stmon.steval&nbsp;(comp_store&nbsp;a&nbsp;v&nbsp;lr)&nbsp;cs)&nbsp;<span class="inlinecode"></span>&nbsp;in<br/>
&nbsp;&nbsp;match&nbsp;(V.Opsem.eval_once_and_until_pc&nbsp;g&nbsp;st&nbsp;(block_entry&nbsp;lr)&nbsp;1000)&nbsp;with<br/>
&nbsp;&nbsp;|&nbsp;inl&nbsp;err&nbsp;=&gt;&nbsp;whenFail&nbsp;("comp_store_correct:&nbsp;"&nbsp;++&nbsp;err)&nbsp;false<br/>
&nbsp;&nbsp;|&nbsp;inr&nbsp;st'&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(eq_dec_pc&nbsp;(V.Opsem.st_pc&nbsp;st')&nbsp;(block_entry&nbsp;lr))&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;new_dom&nbsp;:=&nbsp;(v&nbsp;::&nbsp;vst_mem_dom&nbsp;vst)&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whenFail&nbsp;(":::&nbsp;cfg&nbsp;is:&nbsp;"&nbsp;++&nbsp;show&nbsp;g&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;initial&nbsp;state&nbsp;pc:&nbsp;"&nbsp;++&nbsp;show&nbsp;(vst_pc&nbsp;vst)&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;le:&nbsp;"&nbsp;++&nbsp;show&nbsp;le&nbsp;++&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;lr:&nbsp;"&nbsp;++&nbsp;show&nbsp;lr&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;store&nbsp;to&nbsp;"&nbsp;++&nbsp;show&nbsp;v&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;curr&nbsp;pc:&nbsp;"&nbsp;++&nbsp;show&nbsp;(block_entry&nbsp;lr)&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;final&nbsp;memory:&nbsp;"&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_memory&nbsp;(V.Opsem.st_mem&nbsp;st')&nbsp;new_dom&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&nbsp;:::&nbsp;initial&nbsp;memory:&nbsp;"&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_memory&nbsp;(V.Opsem.st_mem&nbsp;st)&nbsp;new_dom)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memory_on_domain_checker&nbsp;new_dom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(V.Opsem.st_mem&nbsp;st')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(V.Opsem.Memory.update&nbsp;(V.Opsem.st_mem&nbsp;st)&nbsp;v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aeval&nbsp;a&nbsp;(V.Opsem.st_mem&nbsp;st))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;whenFail&nbsp;"comp_store_correct:&nbsp;pc&nbsp;not&nbsp;expected"&nbsp;false<br/>
&nbsp;&nbsp;end.<br/>
&nbsp;*)</span><br/>

<br/>
<span class="comment">(*<br/>
Definition&nbsp;comp_store_correct_checker_inner<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(a&nbsp;:&nbsp;aexp)&nbsp;(v:&nbsp;addr)&nbsp;(lr&nbsp;le:&nbsp;lbl)&nbsp;(cs:&nbsp;list&nbsp;uid)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst:&nbsp;vminus_state)<br/>
&nbsp;&nbsp;:&nbsp;Checker&nbsp;:=<br/>
&nbsp;&nbsp;let&nbsp;st&nbsp;:=&nbsp;V.Opsem.mkst&nbsp;(vst_mem&nbsp;vst)&nbsp;(block_entry&nbsp;le)&nbsp;(vst_loc&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_ppc&nbsp;vst)&nbsp;(vst_ploc&nbsp;vst)&nbsp;in<br/>
&nbsp;&nbsp;let&nbsp;'(g,&nbsp;end_pc)&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrap_code_in_cfg&nbsp;(block_entry&nbsp;le)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(steval&nbsp;(comp_store&nbsp;a&nbsp;v&nbsp;lr)&nbsp;cs)&nbsp;<span class="inlinecode"></span>&nbsp;in<br/>
&nbsp;&nbsp;match&nbsp;(V.Opsem.eval_once_and_until_pc&nbsp;g&nbsp;st&nbsp;(block_entry&nbsp;lr)&nbsp;1000)&nbsp;with<br/>
&nbsp;&nbsp;|&nbsp;inl&nbsp;err&nbsp;=&gt;&nbsp;whenFail&nbsp;("comp_store_correct:&nbsp;"&nbsp;++&nbsp;err)&nbsp;false<br/>
&nbsp;&nbsp;|&nbsp;inr&nbsp;st'&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(eq_dec_pc&nbsp;(V.Opsem.st_pc&nbsp;st')&nbsp;(block_entry&nbsp;lr))&nbsp;then<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let&nbsp;new_dom&nbsp;:=&nbsp;(v&nbsp;::&nbsp;vst_mem_dom&nbsp;vst)&nbsp;in<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whenFail&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"comp_store_correct:&nbsp;memories&nbsp;mismatch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memory_on_domain_checker&nbsp;new_dom<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(V.Opsem.st_mem&nbsp;st')<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(V.Opsem.Memory.update&nbsp;(V.Opsem.st_mem&nbsp;st)&nbsp;v<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(aeval&nbsp;a&nbsp;(V.Opsem.st_mem&nbsp;st))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;whenFail&nbsp;"comp_store_correct:&nbsp;pc&nbsp;not&nbsp;expected"&nbsp;false<br/>
&nbsp;&nbsp;end.<br/>
<br/>
Definition&nbsp;comp_store_correct_checker:&nbsp;Checker&nbsp;:=<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(a:&nbsp;aexp)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(v:&nbsp;addr)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(lr:&nbsp;lbl)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(le:&nbsp;lbl)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(cs:&nbsp;list&nbsp;uid)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(vst:&nbsp;vminus_state)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;comp_store_correct_checker_inner&nbsp;a&nbsp;v&nbsp;lr&nbsp;le&nbsp;cs&nbsp;vst)))))).<br/>
<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_store_correct_checker.&nbsp;*)</span><br/>
<br/>
<br/>
Definition&nbsp;comp_cond_correct_checker_inner<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(b:&nbsp;bexp)&nbsp;(cs:&nbsp;list&nbsp;uid)&nbsp;(le&nbsp;l<sub>1</sub>&nbsp;l<sub>2</sub>:&nbsp;lbl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst:&nbsp;vminus_state)<br/>
&nbsp;&nbsp;:&nbsp;Checker&nbsp;:=<br/>
&nbsp;&nbsp;let&nbsp;st&nbsp;:=&nbsp;V.Opsem.mkst&nbsp;(vst_mem&nbsp;vst)&nbsp;(block_entry&nbsp;le)&nbsp;(vst_loc&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vst_ppc&nbsp;vst)&nbsp;(vst_ploc&nbsp;vst)&nbsp;in<br/>
&nbsp;&nbsp;let&nbsp;'(g,&nbsp;end_pc)&nbsp;:=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrap_code_in_cfg&nbsp;(block_entry&nbsp;le)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(Stmon.steval&nbsp;(comp_cond&nbsp;b&nbsp;l<sub>1</sub>&nbsp;l<sub>2</sub>)&nbsp;cs)&nbsp;<span class="inlinecode"></span>&nbsp;in<br/>
&nbsp;&nbsp;let&nbsp;l&nbsp;:=&nbsp;(if&nbsp;beval&nbsp;b&nbsp;(V.Opsem.st_mem&nbsp;st)&nbsp;then&nbsp;l<sub>1</sub>&nbsp;else&nbsp;l<sub>2</sub>)&nbsp;in&nbsp;&nbsp;<br/>
&nbsp;&nbsp;match&nbsp;(V.Opsem.eval_until_pc&nbsp;g&nbsp;st&nbsp;(block_entry&nbsp;l)&nbsp;1000)&nbsp;with<br/>
&nbsp;&nbsp;|&nbsp;inl&nbsp;err&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;whenFail&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(":::&nbsp;cfg&nbsp;is:&nbsp;"&nbsp;++&nbsp;show&nbsp;g&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;":::&nbsp;comp_cond_correct:&nbsp;"&nbsp;++&nbsp;err&nbsp;++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;":::&nbsp;looking&nbsp;for&nbsp;pc:&nbsp;"&nbsp;++&nbsp;show&nbsp;end_pc<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false<br/>
&nbsp;&nbsp;|&nbsp;inr&nbsp;st'&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(eq_dec_pc&nbsp;(V.Opsem.st_pc&nbsp;st')&nbsp;(block_entry&nbsp;l))&nbsp;then&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;whenFail&nbsp;"comp_store_correct:&nbsp;memories&nbsp;mismatch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(memory_on_domain_checker&nbsp;(vst_mem_dom&nbsp;vst)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(V.Opsem.st_mem&nbsp;st)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(V.Opsem.st_mem&nbsp;st'))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;whenFail&nbsp;"comp_cond_correct:&nbsp;pc&nbsp;not&nbsp;expected"&nbsp;false<br/>
&nbsp;&nbsp;end.<br/>
<br/>
Definition&nbsp;comp_cond_correct_checker&nbsp;:&nbsp;Checker&nbsp;:=<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(b:&nbsp;bexp)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(le:&nbsp;lbl)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(l<sub>1</sub>:&nbsp;lbl)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(l<sub>2</sub>:&nbsp;lbl)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(cs:&nbsp;list&nbsp;uid)&nbsp;=&gt;<br/>
&nbsp;&nbsp;forAll&nbsp;arbitrary&nbsp;(fun&nbsp;(vst:&nbsp;vminus_state)&nbsp;=&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;comp_cond_correct_checker_inner&nbsp;b&nbsp;cs&nbsp;le&nbsp;l<sub>1</sub>&nbsp;l<sub>2</sub>&nbsp;vst)))))).<br/>
<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_cond_correct_checker.&nbsp;*)</span><br/>
<br/>
*)</span><br/>
</div>

<div class="doc">
<a name="lab100"></a><h3 class="section">NOT DONE</h3>

Definition match_config_checker
           (c: Imp.com) ((g, l<sub>1</sub> l<sub>2</sub>): cfg * lbl * lbl)
  : Checker :=
  match c with
  | SKIP =&gt; whenFail "match_config: labels not equal for skip"
                    (eq_dec_lbl l<sub>1</sub> l<sub>2</sub>)
  | 

<div class="paragraph"> </div>

Inductive match_config : Imp.com -&gt; (cfg * lbl * lbl) -&gt; Prop :=
  | MC_Skip : forall bs l,
      match_config SKIP (bs, l, l)
  | MC_Ass : forall g l l' uid a cs,
      insns_at_pc g (block_entry l) (steval (comp_store a uid l') cs) -&gt;
      match_config (CAss uid a) (g, l, l')
  | MC_Seq : forall g l<sub>1</sub> l<sub>2</sub> l<sub>3</sub> c<sub>1</sub> c<sub>2</sub>,
      match_config c<sub>1</sub> (g, l<sub>1</sub>, l<sub>2</sub>) -&gt;
      match_config c<sub>2</sub> (g, l<sub>2</sub>, l<sub>3</sub>) -&gt;
      match_config (CSeq c<sub>1</sub> c<sub>2</sub>) (g, l<sub>1</sub>, l<sub>3</sub>)
  | MC_If : forall g le lr l<sub>1</sub> l<sub>2</sub> b c<sub>1</sub> c<sub>2</sub> cs,
      match_config c<sub>1</sub> (g, l<sub>1</sub>, lr) -&gt;
      match_config c<sub>2</sub> (g, l<sub>2</sub>, lr) -&gt;
      insns_at_pc g (block_entry le) (steval (comp_cond b l<sub>1</sub> l<sub>2</sub>) cs) -&gt;
      match_config (CIf b c<sub>1</sub> c<sub>2</sub>) (g, le, lr)
  | MC_While : forall g le lb lr b c cs,
      match_config c (g, lb, le) -&gt;
      insns_at_pc g (block_entry le) (steval (comp_cond b lb lr) cs) -&gt;
      match_config (CWhile b c) (g, le, lr).

<div class="paragraph"> </div>

Inductive match_config : Imp.com -&gt; (ListCFG.t * lbl * lbl) -&gt; Prop :=
  | MC_Skip : forall bs l,
      match_config SKIP (bs, l, l)
  | MC_Ass : forall g l l' uid a cs,
      insns_at_pc g (block_entry l) (steval (comp_store a uid l') cs) -&gt;
      match_config (CAss uid a) (g, l, l')
  | MC_Seq : forall g l<sub>1</sub> l<sub>2</sub> l<sub>3</sub> c<sub>1</sub> c<sub>2</sub>,
      match_config c<sub>1</sub> (g, l<sub>1</sub>, l<sub>2</sub>) -&gt;
      match_config c<sub>2</sub> (g, l<sub>2</sub>, l<sub>3</sub>) -&gt;
      match_config (CSeq c<sub>1</sub> c<sub>2</sub>) (g, l<sub>1</sub>, l<sub>3</sub>)
  | MC_If : forall g le lr l<sub>1</sub> l<sub>2</sub> b c<sub>1</sub> c<sub>2</sub> cs,
      match_config c<sub>1</sub> (g, l<sub>1</sub>, lr) -&gt;
      match_config c<sub>2</sub> (g, l<sub>2</sub>, lr) -&gt;
      insns_at_pc g (block_entry le) (steval (comp_cond b l<sub>1</sub> l<sub>2</sub>) cs) -&gt;
      match_config (CIf b c<sub>1</sub> c<sub>2</sub>) (g, le, lr)
  | MC_While : forall g le lb lr b c cs,
      match_config c (g, lb, le) -&gt;
      insns_at_pc g (block_entry le) (steval (comp_cond b lb lr) cs) -&gt;
      match_config (CWhile b c) (g, le, lr).

<div class="paragraph"> </div>

Inductive match_states (g:cfg) (r:lbl)
  : (com * Imp.state) -&gt; Opsem.state -&gt; Prop :=
  match_states_intro : forall c mem st l,
    match_config c (g, l, r) -&gt;
    st_pc st = block_entry l -&gt;
    st_mem st = mem -&gt;
    match_states g r (c, mem) st.

<div class="paragraph"> </div>

Lemma simulation_step' :
  forall g c c' mem mem' st r,
  Imp.step (c, mem) (c', mem') -&gt;
  match_states g r (c, mem) st -&gt;
  exists st',
    star (Opsem.step g) st st' /\
    match_states g r (c', mem') st'.

<div class="paragraph"> </div>

Lemma simulation_step' :
  forall c mem mem' st r,
  let '(c', mem') := Imp.step (c, mem) in

<div class="paragraph"> </div>

  match_states g r (c, mem) st -&gt;
  exists st',
    star (Opsem.step g) st st' /\
    match_states g r (c', mem') st'.

<div class="paragraph"> </div>

Lemma transl_sim_step_final :
  forall g r imp_st imp_st' vmn_st,
  Imp.step imp_st imp_st' -&gt;
  match_states g r imp_st vmn_st -&gt;
  exists vmn_st',
    (plus (Opsem.step g) vmn_st vmn_st' \/
     star (Opsem.step g) vmn_st vmn_st' /\ imp_size imp_st' &lt; imp_size imp_st) /\
    match_states g r imp_st' vmn_st'.

</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>