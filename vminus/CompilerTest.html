<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="common/css/sf.css" rel="stylesheet" type="text/css"/>
<title>CompilerTest</title>
</head>
<link href="common/jquery-ui/jquery-ui.css" rel="stylesheet">
<script src="common/jquery-ui/external/jquery/jquery.js"></script>
<script src="common/jquery-ui/jquery-ui.js"></script>
<script src="common/toggleproofs.js"></script>
<link href="common/css/lf.css" rel="stylesheet" type="text/css"/>

<body>

<div id="page">

<div id="header">
<a href='https://www.cis.upenn.edu/~bcpierce/sf/current/index.html'>
<img src='common/media/image/sf_logo_sm.png'></a>
<ul id='menu'>
   <a href='index.html'><li class='section_name'>VMinus Development</li></a>
   <a href='toc.html'><li>Table of Contents</li></a>
   <a href='coqindex.html'><li>Index</li></a>
   <a href='deps.html'><li>Roadmap</li></a>
</ul>
</div>

<div id="main">

<h1 class="libtitle">CompilerTest</h1>

<div class="code code-tight">
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">List</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">ListNotations</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">String</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Arith</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">QuickChick.QuickChick</span>.<br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">QcDefaultNotation</span>. <span class="id" type="keyword">Open</span> <span class="id" type="keyword">Scope</span> <span class="id" type="var">qc_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Classes</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Vminus</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Atom</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.CFG</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.ListCFG</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Imp</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Compiler</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.VminusOpSem</span>. <span class="comment">(*&nbsp;More&nbsp;refactoring&nbsp;work&nbsp;to&nbsp;do&nbsp;*)</span><br/>
<span class="id" type="keyword">Import</span> <span class="id" type="var">V.Opsem</span>.<br/>

<br/>
<span class="comment">(*&nbsp;Exercise&nbsp;imports&nbsp;*)</span><br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.AtomGen</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.ImpGen</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.OpSemGen</span>.<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">Vminus.Stmon</span>.<br/>
</div>

<div class="doc">
<a name="lab99"></a><h2 class="section">QuickChick and Vellvm</h2>
 One may expect a compiler for a language as simple as IMP to be relatively 
    straightforward, and a proof of its correctness to be correspondingly
    so. However, LLVM is a full-featured IR, and a faithful formalization 
    is necessarily complex and large. When the compiler is under development, 
    even stating the correctness of the compiler can be difficult, much 
    less prove it.

<div class="paragraph"> </div>

    But if we have interpreters for both the source and target, testing the 
    compiler is a much simpler affair. Moreover, the simplicity of the source 
    language, i.e. Imp. means that it is really easy to test! 
<div class="paragraph"> </div>

 This lecture shows how QuickChick can be used to test the compiler. For
    simplicity, the target language is the simplified SSA language Vminus, and
    we use a variant of Imp whose names are just memory addresses which can be 
    interpreted in the memory of Vminus states. Imp states and Vminus memory
    are hence essentially the same, and this makes it easy to state correct 
    compilation: after running the source program and its compilation, 
    every Imp variable/address is mapped to the same nat by both the Imp state 
    and Vminus memory. 

<div class="paragraph"> </div>

    A Vminus state consists of a memory (mapping addresses to nat), a program 
    counter, an environment mapping locals to nat, a "previous" program 
    counter, and a "previous" environment. The latter two are needed for
    executing phi nodes. A configuration consists of a Vminus state and a CFG,
    which "holds" Vminus instructions organized in basic blocks.

<div class="paragraph"> </div>

 Here's a look at what we mean. 

<div class="paragraph"> </div>

Theorem compile_program_correct_terminating:
  forall c m m' g le lr,
  (g, le, lr) = compile c -&gt;
  imp_terminates c m m' -&gt;
  vminus_terminates g m m'.

<div class="paragraph"> </div>

  This is one of the top-level correctness theorems for the compiler: for any 
  initial memory m, if the source program c terminates with memory (Imp state) 
  m', running the compilation result g (a control flow graph holding the 
  instructions) on the same initial memory m also results in termination, and
  with its final (Vminus) memory also being m. This is where the coincidence of 
  Imp states and Vminus memory comes into play.

<div class="paragraph"> </div>

  Terminating Imp programs are those that are evaluated to just SKIP, as the
  following definition shows. 

<div class="paragraph"> </div>

  Definition imp_terminates (c: com) (m m':mem) : Prop :=
    star Imp.step (c, m) (SKIP, m').

<div class="paragraph"> </div>

  For Vminus programs on the other hand, running them on an initial memory m 
  leads to termination with memory m' if execution reaches some uid x 
  associated with a return terminator.

<div class="paragraph"> </div>

  Definition vminus_terminates (g:ListCFG.t) (m m':mem) : Prop :=
    exists x st',
      insns_at_pc g st'.(st_pc) <span class="inlinecode">(<span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">cmd_tmn</span></span> <span class="inlinecode"><span class="id" type="var">tmn_ret</span>)</span> /\
      st'.(st_mem) = m' /\
      star (step g) (init_state g m) st'.

<div class="paragraph"> </div>

  The variables x and st' here are determined by "running"/evaluation, as 
  indicated by "star (step g) (init_state g m) st'". So checking for their 
  existence is really verifying that an evaluation function reaches st' 
  satisfying the constraints. 
 
<div class="paragraph"> </div>

 Let us try to write a Checker for the theorem. Looking at the universals, 
    it would appear that we need generators for Imp commands (c), Imp 
    states/memories (m, m'), control flow graphs (g) and labels (le, lr).
    However, note that g, le, and lr are computed by "compile c", so we 
    don't actually need generators for them. Moreover, we do not want just any 
    c and m', but only terminating Imp programs, and m' is obtained by running
    an Imp evaluator on m. Hence for generation, we only need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A generator for mem. 

</li>
<li> A generator for Imp programs that are guaranteed to terminate. 

</li>
</ul>
    And for checking, we would need:

<div class="paragraph"> </div>

<ul class="doclist">
<li> An evaluator for Imp that reaches termination, i.e. SKIP.

</li>
<li> An evaluator for Vminus that reaches termination, i.e. a return 
      terminator. 

</li>
<li> We also need to check that the final state st' that the Vminus evaluator 
      reaches has the desired memory.

</li>
</ul>

<div class="paragraph"> </div>

 Let us first define an evaluator for Vminus. The evaluator stops when 
    a return terminator is reached. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">vminus_eval</span> (<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">s</span> : <span class="id" type="var">state</span>) (<span class="id" type="var">fuel</span>: <span class="id" type="var">nat</span>) : <span class="id" type="var">err</span> <span class="id" type="var">state</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">fuel</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">inl</span> "out of fuel"<br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">ListCFG.fetch</span> <span class="id" type="var">g</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">s</span>)) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">instr</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_cmd</span> (<span class="id" type="var">snd</span> <span class="id" type="var">instr</span>) (<span class="id" type="var">cmd_tmn</span> <span class="id" type="var">tmn_ret</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">inr</span> <span class="id" type="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">eval_step</span> <span class="id" type="var">g</span> <span class="id" type="var">s</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">s'</span> ⇒ <span class="id" type="var">vminus_eval</span> <span class="id" type="var">g</span> <span class="id" type="var">s'</span> <span class="id" type="var">n'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">inl</span> <span class="id" type="var">err</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">inl</span> "no instr to fetch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
It is likely that QuickChick will generate large enough Imp programs such 
    that vminus_eval can run out of fuel. (Think of large aexp expressions.)

<div class="paragraph"> </div>

    Exercise: Write an instance of GenSized for aexp and bexp such that 
    any size above a certain number, say 5, is rounded down to that. The 
    GenSized instance for bexp should make use of that for aexp. 
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="var">Derive</span> <span class="id" type="var">Arbitrary</span> <span class="id" type="keyword">for</span> <span class="id" type="var">aexp</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">round_down_to</span> (<span class="id" type="var">n</span>: <span class="id" type="var">nat</span>) (<span class="id" type="var">k</span>: <span class="id" type="var">nat</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">lt_dec</span> <span class="id" type="var">n</span> <span class="id" type="var">k</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">n</span> <span class="id" type="keyword">else</span> <span class="id" type="var">k</span>.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gen_small_aexp</span>: <span class="id" type="var">GenSized</span> <span class="id" type="var">aexp</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;{| <span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span> := @<span class="id" type="var">arbitrarySized</span> <span class="id" type="var">aexp</span> <span class="id" type="var">_</span> (<span class="id" type="var">round_down_to</span> 5 <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;|}.<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gen_small_bexp</span>: <span class="id" type="var">GenSized</span> <span class="id" type="var">bexp</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;{| <span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">fix</span> <span class="id" type="var">gen_bexp_func</span> <span class="id" type="var">n</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">elems</span> [<span class="id" type="var">BTrue</span> ; <span class="id" type="var">BFalse</span>]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">beq_gen</span> := <span class="id" type="var">liftGen2</span> <span class="id" type="var">BEq</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">ble_gen</span> := <span class="id" type="var">liftGen2</span> <span class="id" type="var">BLe</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">arbitrarySized</span> <span class="id" type="var">n</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">bnot_gen</span> := <span class="id" type="var">liftGen</span> <span class="id" type="var">BNot</span> (<span class="id" type="var">gen_bexp_func</span> <span class="id" type="var">n'</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">band_gen</span> := <span class="id" type="var">liftGen2</span> <span class="id" type="var">BAnd</span> (<span class="id" type="var">gen_bexp_func</span> <span class="id" type="var">n'</span>) (<span class="id" type="var">gen_bexp_func</span> <span class="id" type="var">n'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oneOf</span> [ <span class="id" type="var">beq_gen</span> ; <span class="id" type="var">ble_gen</span> ; <span class="id" type="var">bnot_gen</span> ; <span class="id" type="var">band_gen</span> ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">gen_bexp_func</span> (<span class="id" type="var">round_down_to</span> 5 <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;|}.<br/>
</div>

<div class="doc">
For com, recall that the lemma applies only to terminating ones. Hence, 
    write two sized generators for com: 

<div class="paragraph"> </div>

<ul class="doclist">
<li> one that generates only assignment statements and SKIPs, such that the 
      latter are generated with low probability.

</li>
<li> one that generates IF-THEN-ELSE, assignments and SKIPs, but no loops.

</li>
</ul>
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">gen_seq_com</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>) : <span class="id" type="var">G</span> <span class="id" type="var">com</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span> <br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">freq</span> [(4, <span class="id" type="var">liftGen2</span> <span class="id" type="var">CAss</span> <span class="id" type="var">arbitrary</span> <span class="id" type="var">arbitrary</span>); (1, <span class="id" type="var">returnGen</span> <span class="id" type="var">SKIP</span>)]<br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gen</span> := <span class="id" type="var">gen_seq_com</span> <span class="id" type="var">n'</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">liftGen2</span> <span class="id" type="var">CSeq</span> <span class="id" type="var">gen</span> <span class="id" type="var">gen</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">gen_if_com</span> (<span class="id" type="var">n</span>: <span class="id" type="var">nat</span>) : <span class="id" type="var">G</span> <span class="id" type="var">com</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| 0 ⇒ <span class="id" type="var">freq</span> [(1, <span class="id" type="var">returnGen</span> <span class="id" type="var">CSkip</span>) ;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4, <span class="id" type="var">liftGen2</span> <span class="id" type="var">CAss</span> <span class="id" type="var">arbitrary</span> <span class="id" type="var">arbitrary</span>)]<br/>
&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">n'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gen</span> := <span class="id" type="var">gen_if_com</span> <span class="id" type="var">n'</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oneOf</span> [<span class="id" type="var">liftGen3</span> <span class="id" type="var">CIf</span> <span class="id" type="var">arbitrary</span> <span class="id" type="var">gen</span> <span class="id" type="var">gen</span>; <span class="id" type="var">liftGen2</span> <span class="id" type="var">CSeq</span> <span class="id" type="var">gen</span> <span class="id" type="var">gen</span>]<br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
For your convenience, the Shows and Shrinks for aexp, bexp and com have 
    been defined. 
<div class="paragraph"> </div>

 The last thing we need a generator for is mem. One could generate this by 
    first generating a subset of its domain, i.e. Atom.t, and then generating 
    the image for this subset; the rest would be kept as some initial value. 

<div class="paragraph"> </div>

 Write a function that outputs a generator for mem, given a list of 
    atoms. 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_mem_from_atom_list</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">atom_list</span> : <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) : <span class="id" type="var">G</span> <span class="id" type="var">mem</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">bindGen</span> (<span class="id" type="var">vectorOf</span> (<span class="id" type="var">List.length</span> <span class="id" type="var">atom_list</span>) <span class="id" type="var">arbitrary</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">nat_list</span> ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="var">returnGen</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span> : <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">index_of_atom_in_list</span> <span class="id" type="var">a</span> <span class="id" type="var">atom_list</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">i</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">List.nth</span> <span class="id" type="var">i</span> <span class="id" type="var">nat_list</span> 0<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)).<br/>
</div>

<div class="doc">
Now write a generator for Atom.t. You may find the function get_fresh_atoms
    useful: it takes in (n: nat) and a list of atoms, and outputs a list of n
    atoms that are distinct from the input. 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">get_fresh_atoms</span> 6 [].<br/>

<br/>
<span class="id" type="keyword">Instance</span> <span class="id" type="var">gen_domain</span> : <span class="id" type="var">Gen</span> <span class="id" type="var">Atom.t</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;{| <span class="id" type="var">arbitrary</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">atom_store</span> := <span class="id" type="var">get_fresh_atoms</span> 100 [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">oneof</span> (<span class="id" type="var">returnGen</span> (<span class="id" type="var">Atom.fresh</span> [])) (<span class="id" type="var">List.map</span> <span class="id" type="var">returnGen</span> <span class="id" type="var">atom_store</span>)<br/>
&nbsp;&nbsp;|}.<br/>
</div>

<div class="doc">
It would be convenient to show memory too. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">show_memory</span>.<br/>
</div>

<div class="doc">
With generation out of the way, we can now return to checking. 
    The Vminus evaluator defined earlier solves a part of the puzzle, namely
    the question of how to check the existence of st' and x. However, we also 
    need to check that st' has the desired memory. Because memories here are 
    total maps, we can only check for equality of memories for a specified 
    domain. 

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">memory_on_domain_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">addr</span>) (<span class="id" type="var">mem1</span> <span class="id" type="var">mem2</span> : <span class="id" type="var">V.Opsem.mem</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">dom</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a</span> :: <span class="id" type="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">Nat.eqb</span> (<span class="id" type="var">mem1</span> <span class="id" type="var">a</span>) (<span class="id" type="var">mem2</span> <span class="id" type="var">a</span>) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">memory_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">mem1</span> <span class="id" type="var">mem2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("memory_equal: memory at " ++ (<span class="id" type="var">show</span> <span class="id" type="var">a</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ " not equal:"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ " mem1 has " ++ (<span class="id" type="var">show</span> (<span class="id" type="var">mem1</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ "; mem2 has " ++ (<span class="id" type="var">show</span> (<span class="id" type="var">mem2</span> <span class="id" type="var">a</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)%<span class="id" type="var">string</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
This lets us assemble the termination checker for Vminus in full. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">vminus_termination_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">m</span> <span class="id" type="var">m'</span>: <span class="id" type="var">mem</span>) (<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">addr</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">vminus_eval</span> <span class="id" type="var">g</span> (<span class="id" type="var">init_state</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span>) 10000 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">final_state</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "vminus_termination_check: memories not equal"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">memory_on_domain_checker</span> <span class="id" type="var">dom</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">final_state</span>) <span class="id" type="var">m'</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> ("vminus_termination_check: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
And therefore, the Checker for the lemma in full. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">compile_program_correct_terminating_checker</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> (<span class="id" type="var">gen_seq_com</span> 5) (<span class="id" type="keyword">fun</span> (<span class="id" type="var">c</span> : <span class="id" type="var">Imp.com</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">dom</span> : <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> (<span class="id" type="var">gen_mem_from_atom_list</span> <span class="id" type="var">dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ []) <span class="comment">(*&nbsp;dummy&nbsp;shrinker&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">show_memory</span> <span class="id" type="var">m</span> <span class="id" type="var">dom</span>) <span class="comment">(*&nbsp;show&nbsp;just&nbsp;for&nbsp;the&nbsp;domain&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">le</span>, <span class="id" type="var">lr</span>) := <span class="id" type="var">compile</span> <span class="id" type="var">c</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">imp_eval</span> <span class="id" type="var">c</span> <span class="id" type="var">m</span> 100 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">s'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">vminus_termination_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">m</span> <span class="id" type="var">s'</span> <span class="id" type="var">dom</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "compile_program_termination: cannot eval imp to Skip"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>))).<br/>
</div>

<div class="doc">
Note the use of forAllShrinkShow here, which lets us choose the specific 
    Show we want to use; it is needed here because we don't have a Show 
    instance for total maps like mem. 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;compile_program_correct_terminating_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
For the next part, let us go into the sort of lemmas that would be needed 
    to prove the top-level correctness theorems like the one above. Here's one.

<div class="paragraph"> </div>

Lemma comp_aexp_correct : forall (a:aexp),
    comp_correct (comp_aexp a) (aeval a).

<div class="paragraph"> </div>

Definition comp_correct (comp : ectmon (val * list insn))
           (eval : mem -&gt; nat) : Prop :=
  forall (cs cs': list uid) (g: ListCFG.t) (st: V.Opsem.state)
    (is k: list insn) (v: val), 
    (cs', (v, is)) = comp cs -&gt;
    insns_at_pc g (st_pc st) (is ++ k) -&gt;
    exists st',
      st_mem st' = st_mem st /\
      insns_at_pc g (st_pc st') k /\
      star (Opsem.step g) st st' /\
      ids_preserved cs st st' /\
      good_return cs' v /\
      ctx_incr cs cs' /\
      eval_val (st_loc st') v = Some (eval (st_mem st)).

<div class="paragraph"> </div>

 That is, compiling Imp aexp is correct if:

<div class="paragraph"> </div>

<ul class="doclist">
<li> for any compilation run on an initial list of uids, 

</li>
<li> wherever we place the compilation result "is" in the CFG, as long
      as the pc is pointed to it, (insns_at_pc g (st_pc) (is ++ k)),

</li>
<li> we can run to the end of compilation (insns_at_pc g (st_pc st') k),

</li>
<li> and in this state st', the memory is the same as above; but evaluating 
      the result of the expression in this state (eval_val (st_loc st') v)
      is exactly the same as evaluating it according to the Imp state
      (eval (st_mem st)). 

</li>
<li> This last fact may not be obvious from the body of comp_correct. But note 
      comp_aexp_correct; the evaluation function passed to it is Imp's aeval, 
      and this is where the coincidence of Imp states and Vminus memory comes 
      into play.

</li>
</ul>
    There is a bunch of other things that we need here, so as to prove correct
    compilation for com. But the above description is the crux.

<div class="paragraph"> </div>

 Looking at comp_correct, it is clear that we need to generate more than 
    just the things we had before. In particular, it would seem that we need 
    generators for the following:

<div class="paragraph"> </div>

<ul class="doclist">
<li> uid

</li>
<li> CFG

</li>
<li> Vminus states

</li>
<li> Vminus instructions

</li>
<li> values

</li>
</ul>
    But note again that the only value v (with cs', is) is computed by comp 
    rather than generated, so we don't actually need a generator for value. 
    Moreover, the CFG g should not be generated randomly the same way we do 
    others, because it has to satisfy insns_at_pc; it is unlikely for just 
    "any" CFG to satisfy this precondition of the lemma. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

    Exercise: Generators and Shows for uid and Vminus instructions, using 
    automation as much as possible. (It is however useful to have custom Shows 
    that are more descriptive.) 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
</div>

<div class="doc">
For Vminus states, we already have a generator for mem. We have defined a 
    generator and show for loc for you. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">gen_loc_from_atom_list</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">show_locals</span>.<br/>
</div>

<div class="doc">
Hence, write a generator and a show function for Vminus states, 
    given domains for mem and loc. For simplicity, we can use the same 
    domain for ploc. 
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">gen_vminus_state</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) : <span class="id" type="var">G</span> <span class="id" type="var">state</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gmem</span> := <span class="id" type="var">gen_mem_from_atom_list</span> <span class="id" type="var">mem_dom</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">gloc</span> := <span class="id" type="var">gen_loc_from_atom_list</span> <span class="id" type="var">mem_dom</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">gmem</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">mem</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">pc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">gloc</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">loc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">ppc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">bindGen</span> <span class="id" type="var">gloc</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">prev_loc</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">returnGen</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mkst</span> <span class="id" type="var">mem</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">pc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">loc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ppc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">prev_loc</span>)))))).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">show_vminus_state</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) : <span class="id" type="var">string</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">show_memory</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="var">mem_dom</span> ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"pc: " ++ <span class="id" type="var">show</span> (<span class="id" type="var">st_pc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">show_locals</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) <span class="id" type="var">loc_dom</span> ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"ppc: " ++ <span class="id" type="var">show</span> (<span class="id" type="var">st_ppc</span> <span class="id" type="var">st</span>) ++ ", " ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"prev_loc: " ++ <span class="id" type="var">show_locals</span> (<span class="id" type="var">st_ploc</span> <span class="id" type="var">st</span>) <span class="id" type="var">loc_dom</span>)%<span class="id" type="var">string</span>.<br/>
</div>

<div class="doc">
With these out of the way, we can now address the remaining gaps. In its 
    current form, comp_correct is inefficient and challenging for testing. 
    Firstly, some of the quantities are computed by a function, so it is 
    unnecessary to generate them in the first place, although seemingly 
    suggested by "forall". Secondly, the CFG g is not just any CFG, but one 
    that satisfies insns_at_pc for the compilation result - random generation 
    in the usual way is very, very unlikely to meet this condition, so most
    checks would end up being vacuously true. Thirdly, a Checker for the 
    the existence of st' really needs to compute it, and this is not part of
    the lemma itself. 

<div class="paragraph"> </div>

    Hence the first order of affairs is to massage the lemma into a 
    Checker-friendly version.
 
<div class="paragraph"> </div>

 Firstly, let us drop the unnecessary variables, and note the generation 
    of state.

<div class="paragraph"> </div>

    Definition comp_correct (comp : ectmon (val * list insn))
                            (eval : mem -&gt; nat) : Prop :=
      forall (cs: list uid) (g: ListCFG.t) (k: list insn),
      forall (mem_dom: list Atom.t) (loc_dom: list Atom.t) (st: state),

<div class="paragraph"> </div>

      let (cs', (v, is)) := comp cs in

<div class="paragraph"> </div>

      insns_at_pc g (st_pc st) (is ++ k) -&gt;
      exists st',
        st_mem st' = st_mem st /\
        insns_at_pc g (st_pc st') k /\
        star (Opsem.step g) st st' /\
        ids_preserved cs st st' /\
        good_return cs' v /\
        ctx_incr cs cs' /\
        eval_val (st_loc st') v = Some (eval (st_mem st)).

<div class="paragraph"> </div>

    This is of course not accepted by Coq, but we will eventually get to a
    Checker.
 
<div class="paragraph"> </div>

 Secondly, we need to write a custom generator that generates CFGs 
    satisfying insns_at_pc. An easier option is to just construct a CFG that 
    loads the instructions at a given pc. 

<div class="paragraph"> </div>

    Let us call this wrap_code_in_cfg' pc is k, in correspondence with 
    insns_at_pc g (st_pc st) (is ++ k).

<div class="paragraph"> </div>

    However, because pc may have a positive offset into the block, we should 
    also fill the initial instructions with some dummy instructions (that won't
    be executed). So make wrap_code_in_cfg' do this. 

</div>
<div class="code code-tight">

<br/>
<span class="comment">(*&nbsp;Returns&nbsp;a&nbsp;CFG&nbsp;with&nbsp;a&nbsp;single&nbsp;block&nbsp;containing&nbsp;instrs&nbsp;++&nbsp;instrs_after,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;the&nbsp;pc&nbsp;in&nbsp;that&nbsp;block&nbsp;that&nbsp;begins&nbsp;at&nbsp;instrs_after&nbsp;*)</span><br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">wrap_code_in_cfg'</span> (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">instrs</span> <span class="id" type="var">instrs_after</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">ListCFG.t</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">empty_cfg</span> := [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span>) := <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">blocks</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ListCFG.update</span> <span class="id" type="var">empty_cfg</span> <span class="id" type="var">lbl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">generate_dummy_insns</span> <span class="id" type="var">offset</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">instrs</span> ++ <span class="id" type="var">instrs_after</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">lbl</span>, <span class="id" type="var">blocks</span>).<br/>
</div>

<div class="doc">
The to-be-Checkable lemma is thus:

<div class="paragraph"> </div>

    Definition comp_correct (comp : ectmon (val * list insn))
                            (eval : mem -&gt; nat) : Prop :=
      forall (cs: list uid) (k: list insn),
      forall (mem_dom: list Atom.t) (loc_dom: list Atom.t) (st: state),

<div class="paragraph"> </div>

      let (cs', (v, is)) := comp cs in
      let g := wrap_code_in_cfg (st_pc st) is k in

<div class="paragraph"> </div>

      exists st',
        st_mem st' = st_mem st /\
        insns_at_pc g (st_pc st') k /\
        star (Opsem.step g) st st' /\
        ids_preserved cs st st' /\
        good_return cs' v /\
        ctx_incr cs cs' /\
        eval_val (st_loc st') v = Some (eval (st_mem st)). 

<div class="paragraph"> </div>

 Thirdly, if we have grasped the meaning of the lemma, we know that st'
    is given by executing the compilation result; this is the point of 
    "loading" the compilation result at the current pc in g, and is of course 
    also stated by "star (Opsem.step g) st st'". So we need an executable 
    evaluator for Vminus. The state st' is obtained by running this evaluator 
    until we reach (the start of) k. 

<div class="paragraph"> </div>

    The simplest way of doing so is to stop at the program counter that begins
    k, and this is actually determined by the CFG that loaded (is ++ k). 

<div class="paragraph"> </div>

 Exercise: Change wrap_code_in_cfg to return (g, pc), where the latter is 
    the pc that begins k. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">instrs</span> <span class="id" type="var">instrs_after</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">ListCFG.t</span> * <span class="id" type="var">pc</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">empty_cfg</span> := [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span>) := <span class="id" type="var">p</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">blocks</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ListCFG.update</span> <span class="id" type="var">empty_cfg</span> <span class="id" type="var">lbl</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">generate_dummy_insns</span> <span class="id" type="var">offset</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ <span class="id" type="var">instrs</span> ++ <span class="id" type="var">instrs_after</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;((<span class="id" type="var">lbl</span>, <span class="id" type="var">blocks</span>), (<span class="id" type="var">lbl</span>, <span class="id" type="var">offset</span> + <span class="id" type="var">List.length</span> <span class="id" type="var">instrs</span>)).<br/>
</div>

<div class="doc">
Now we need the evaluator itself, which we have defined for you. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">V.Opsem.eval_until_pc</span>.<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">V.Opsem.eval_step</span>.<br/>
</div>

<div class="doc">
Now the lemma is:

<div class="paragraph"> </div>

    Definition comp_correct (comp : ectmon (val * list insn))
                            (eval : mem -&gt; nat) : Prop :=
      forall (cs: list uid) (k: list insn),
      forall (mem_dom: list Atom.t) (loc_dom: list Atom.t) (st: state),

<div class="paragraph"> </div>

      let (cs', (v, is)) := comp cs in
      let (g, endpoint) := wrap_code_in_cfg (st_pc st) is k in

<div class="paragraph"> </div>

      match V.Opsem.eval_until_pc g st cutpoint 1000 with
      | inl err =&gt; false <span class="comment">(*&nbsp;either&nbsp;out&nbsp;of&nbsp;fuel&nbsp;or&nbsp;no&nbsp;st'&nbsp;*)</span><br/>
      | inr st' =&gt; 
        st_mem st' = st_mem st /\
        insns_at_pc g (st_pc st') k /\
        star (Opsem.step g) st st' /\
        ids_preserved cs st st' /\
        good_return cs' v /\
        ctx_incr cs cs' /\
        eval_val (st_loc st') v = Some (eval (st_mem st))
      end.
 
<div class="paragraph"> </div>

 And with this, the major obstacles are out of the way, and we only have
    to write a Checker for the big conjunction. Because the conjunction is 
    huge, it is easier to write a Checker for each conjunct. That is, we would
    like to have:

<div class="paragraph"> </div>

<ul class="doclist">
<li> A Checker that checks that two memories are the same. This has already 
      been done.

</li>
<li> A Checker that checks for insns_at_pc g.

</li>
<li> A Checker for ids_preserved.

</li>
<li> A Checker for good_return.

</li>
<li> A Checker for ctxt_incr.

</li>
<li> A Checker that checks for equality between the two ways of evaluation.

</li>
</ul>
    Note that "star (Opsem.step g) st st'" doesn't need checking, because it is
    implicit in eval_until_pc. With respect to correctness of aexp compilation 
    itself, the last is most relevant. 

<div class="paragraph"> </div>

    To give a headstart, most of these are defined below.

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">loc_on_domain_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span> : <span class="id" type="var">loc</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">dom</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">a</span> :: <span class="id" type="var">l</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">loc1</span> <span class="id" type="var">a</span>, <span class="id" type="var">loc2</span> <span class="id" type="var">a</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n<sub>1</sub></span>, <span class="id" type="var">Some</span> <span class="id" type="var">n<sub>2</sub></span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">Nat.eqb</span> <span class="id" type="var">n<sub>1</sub></span> <span class="id" type="var">n<sub>2</sub></span> <span class="id" type="keyword">then</span> <span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> "loc_equal: locs disagree" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span>, <span class="id" type="var">None</span> ⇒ <span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">l</span> <span class="id" type="var">loc1</span> <span class="id" type="var">loc2</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">_</span>, <span class="id" type="var">_</span> ⇒ <span class="id" type="var">whenFail</span> "loc_equal: locs disagree" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">insns_at_pc_checker</span> `{<span class="id" type="keyword">Show</span> <span class="id" type="var">pc</span>}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>) (<span class="id" type="var">p</span>: <span class="id" type="var">pc</span>) (<span class="id" type="var">k</span> : <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">k</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">uid</span>, <span class="id" type="var">cmd</span>) :: <span class="id" type="var">instrs</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">ListCFG.fetch</span> <span class="id" type="var">g</span> <span class="id" type="var">p</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Some</span> (<span class="id" type="var">uid'</span>, <span class="id" type="var">cmd'</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_cmd</span> <span class="id" type="var">cmd</span> <span class="id" type="var">cmd'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">insns_at_pc_checker</span> <span class="id" type="var">g</span> (<span class="id" type="var">incr_pc</span> <span class="id" type="var">p</span>) <span class="id" type="var">instrs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("insns_at_pc: cmd at pc "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">show</span> <span class="id" type="var">p</span>) ++ " not equal") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("insns_at_pc: uid at pc "<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++ (<span class="id" type="var">show</span> <span class="id" type="var">p</span>) ++ "not equal") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "insns_at_pc: cannot fetch" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">eval_equal_checker</span> (<span class="id" type="var">eval</span>: <span class="id" type="var">mem</span> → <span class="id" type="var">nat</span>) (<span class="id" type="var">st</span>: <span class="id" type="var">state</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">val</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">run_result</span> := <span class="id" type="var">eval_val</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) <span class="id" type="var">v</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">expected_result</span> := <span class="id" type="var">eval</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">run_result</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">Some</span> <span class="id" type="var">n</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "eval_equal: evaluation value not the same"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">Nat.eqb</span> <span class="id" type="var">n</span> <span class="id" type="var">expected_result</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">None</span> ⇒ <span class="id" type="var">whenFail</span> "eval_equal: run did not obtain any value" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">ids_preserved_checker</span> (<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">st</span> <span class="id" type="var">st'</span>: <span class="id" type="var">state</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">loc_on_domain_checker</span> <span class="id" type="var">cs</span> (<span class="id" type="var">st_loc</span> <span class="id" type="var">st</span>) (<span class="id" type="var">st_loc</span> <span class="id" type="var">st'</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">good_return_checker</span> (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">val</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">v</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">val_uid</span> <span class="id" type="var">uid</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "good_return: cannot find value" <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">List.existsb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uid'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>) <span class="id" type="var">cs</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="var">val_nat</span> <span class="id" type="var">n</span> ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="var">ctx_incr_checker</span> (<span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">cs</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| [] ⇒ <span class="id" type="var">checker</span> <span class="id" type="var">true</span><br/>
&nbsp;&nbsp;| (<span class="id" type="var">uid</span> :: <span class="id" type="var">uids</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">List.existsb</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">uid'</span> ⇒ <span class="id" type="keyword">if</span> <span class="id" type="var">eq_dec_uid</span> <span class="id" type="var">uid</span> <span class="id" type="var">uid'</span> <span class="id" type="keyword">then</span> <span class="id" type="var">true</span> <span class="id" type="keyword">else</span> <span class="id" type="var">false</span>) <span class="id" type="var">cs'</span>) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr_checker</span> <span class="id" type="var">uids</span> <span class="id" type="var">cs'</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> ("ctx_incr: " ++ <span class="id" type="var">show</span> <span class="id" type="var">uid</span> ++ " not found") <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>

<div class="doc">
We can now compose the checkers using QuickChick's conjoin combinator. 
</div>
<div class="code code-tight">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">expression_step_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">eval</span>: <span class="id" type="var">V.Opsem.mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">g</span>: <span class="id" type="var">ListCFG.t</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">initial_state</span> <span class="id" type="var">final_state</span>: <span class="id" type="var">V.Opsem.state</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">k</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) (<span class="id" type="var">end_of_expr</span>: <span class="id" type="var">pc</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">v</span> : <span class="id" type="var">val</span>) : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">conjoin</span> [<span class="id" type="var">ids_preserved_checker</span> <span class="id" type="var">cs</span> <span class="id" type="var">initial_state</span> <span class="id" type="var">final_state</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">insns_at_pc_checker</span> <span class="id" type="var">g</span> <span class="id" type="var">end_of_expr</span> <span class="id" type="var">k</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">good_return_checker</span> <span class="id" type="var">cs'</span> <span class="id" type="var">v</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">ctx_incr_checker</span> <span class="id" type="var">cs</span> <span class="id" type="var">cs'</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">eval_equal_checker</span> <span class="id" type="var">eval</span> <span class="id" type="var">final_state</span> <span class="id" type="var">v</span>].<br/>
</div>

<div class="doc">
Finally, a Checker for comp_correct and comp_aexp could look like the 
    following. It is convenient to split the Checker into a part that does 
    only the generation, and a part that does the checking, because a type 
    error can cause the typechecker to get stuck trying to resolve the issue
    by looking for typeclass instances that don't exist.    

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp</span>: <span class="id" type="var">ectmon</span> (<span class="id" type="var">val</span> * <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)) (<span class="id" type="var">eval</span>: <span class="id" type="var">V.Opsem.mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">st</span>: <span class="id" type="var">V.Opsem.state</span>) (<span class="id" type="var">k</span>: <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">cs'</span>, (<span class="id" type="var">v</span>, <span class="id" type="var">instrs</span>)) := <span class="id" type="var">comp</span> <span class="id" type="var">cs</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">endpoint</span>) := <span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">V.Opsem.st_pc</span> <span class="id" type="var">st</span>) <span class="id" type="var">instrs</span> <span class="id" type="var">k</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">V.Opsem.eval_until_pc</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="var">endpoint</span> 1000 <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">whenFail</span> ("comp_correct_checker: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">st'</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">expression_step_checker</span> <span class="id" type="var">eval</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> <span class="id" type="var">st'</span> <span class="id" type="var">k</span> <span class="id" type="var">endpoint</span> <span class="id" type="var">cs</span> <span class="id" type="var">cs'</span> <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_correct_checker</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp</span>: <span class="id" type="var">ectmon</span> (<span class="id" type="var">val</span> * <span class="id" type="var">list</span> <span class="id" type="var">insn</span>)) (<span class="id" type="var">eval</span>: <span class="id" type="var">V.Opsem.mem</span> → <span class="id" type="var">nat</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">cs</span> : <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">extra_insn</span> : <span class="id" type="var">list</span> <span class="id" type="var">insn</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> (<span class="id" type="var">gen_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ [])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">show_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">start_state</span>: <span class="id" type="var">state</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp</span> <span class="id" type="var">eval</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">cs</span> <span class="id" type="var">start_state</span> <span class="id" type="var">extra_insn</span>))))).<br/>

<br/>
<span class="comment">(**!&nbsp;Section&nbsp;test_compile_aexp&nbsp;extends&nbsp;compiler&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_aexp_correct_checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">a</span>: <span class="id" type="var">aexp</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;collect&nbsp;a&nbsp;(&nbsp;*)</span> <span class="id" type="var">comp_correct_checker</span> (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a</span>) (<span class="id" type="var">aeval</span> <span class="id" type="var">a</span>)).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_aexp_correct_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
Since the compiler has already been proven correct, all tests should 
    succeed. However, they could be succeeding for rather vacuous reasons, and 
    it would be assuring to know that the Checker indeed fails when the 
    compiler is wrong. 

<div class="paragraph"> </div>

    Exercise: Add mutants to comp_aexp, and verify that they are causing 
    comp_aexp_correct_checker to fail. 
 
<div class="paragraph"> </div>

 Exercise: Write a Checker for the following lemma, and run it.

<div class="paragraph"> </div>

Lemma comp_bop_correct : forall b comp1 comp2 eval1 eval2
    (IHa1: comp_correct comp1 eval1)
    (IHa2: comp_correct comp2 eval2),
    comp_correct (comp_bop b comp1 comp2)
                 (fun m =&gt; bop_denote b (eval1 m) (eval2 m)).
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_bop_correct_checker</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a<sub>1</sub></span>: <span class="id" type="var">aexp</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a<sub>2</sub></span>: <span class="id" type="var">aexp</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">binop</span>: <span class="id" type="var">bop</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">collect</span> <span class="id" type="var">binop</span> (<span class="id" type="var">comp_correct_checker</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">comp_bop</span> <span class="id" type="var">binop</span> (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a<sub>1</sub></span>) (<span class="id" type="var">comp_aexp</span> <span class="id" type="var">a<sub>2</sub></span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="var">V.Opsem.bop_denote</span> <span class="id" type="var">binop</span> (<span class="id" type="var">aeval</span> <span class="id" type="var">a<sub>1</sub></span> <span class="id" type="var">m</span>) (<span class="id" type="var">aeval</span> <span class="id" type="var">a<sub>2</sub></span> <span class="id" type="var">m</span>)))))).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_bop_correct_checker.&nbsp;*)</span><br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_bexp_correct_checker</span> : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">b</span>: <span class="id" type="var">bexp</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_correct_checker</span> (<span class="id" type="var">comp_bexp</span> <span class="id" type="var">b</span>) (<span class="id" type="keyword">fun</span> <span class="id" type="var">m</span> ⇒ <span class="id" type="keyword">if</span> (<span class="id" type="var">beval</span> <span class="id" type="var">b</span> <span class="id" type="var">m</span>) <span class="id" type="keyword">then</span> 1 <span class="id" type="keyword">else</span> 0)).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_bexp_correct_checker.&nbsp;*)</span><br/>
</div>

<div class="doc">
Exercise: Write a Checker for the following lemma, and make sure that all 
    tests pass. 

<div class="paragraph"> </div>

Lemma comp_bexp_correct : forall (b:bexp),
  comp_correct (comp_bexp b) (fun m =&gt; b2n (beval b m)).

<div class="paragraph"> </div>

 Exercise: Write a Checker for the following lemma, and make sure that all 
    tests pass.

<div class="paragraph"> </div>

Lemma comp_store_correct : 
  forall g a v le lr cs st,
  insns_at_pc g (block_entry le) (steval (comp_store a v lr) cs) -&gt;
  st_pc st = (block_entry le) -&gt;
  exists st',
    plus (step g) st st' /\
    st_pc st' = (block_entry lr) /\
    st_mem st' = (Memory.update (st_mem st) v (aeval a (st_mem st))).
 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_store_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">a</span> : <span class="id" type="var">aexp</span>) (<span class="id" type="var">v</span>: <span class="id" type="var">addr</span>) (<span class="id" type="var">lr</span> <span class="id" type="var">le</span>: <span class="id" type="var">lbl</span>) (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) (<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) (<span class="id" type="var">vst</span>: <span class="id" type="var">state</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">st</span> := <span class="id" type="var">mkst</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">vst</span>) (<span class="id" type="var">block_entry</span> <span class="id" type="var">le</span>) (<span class="id" type="var">st_loc</span> <span class="id" type="var">vst</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">st_ppc</span> <span class="id" type="var">vst</span>) (<span class="id" type="var">st_ploc</span> <span class="id" type="var">vst</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">end_pc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">block_entry</span> <span class="id" type="var">le</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">steval</span> (<span class="id" type="var">comp_store</span> <span class="id" type="var">a</span> <span class="id" type="var">v</span> <span class="id" type="var">lr</span>) <span class="id" type="var">cs</span>) [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">V.Opsem.eval_once_and_until_pc</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> (<span class="id" type="var">block_entry</span> <span class="id" type="var">lr</span>) 1000) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒ <span class="id" type="var">whenFail</span> ("comp_store_correct: " ++ <span class="id" type="var">err</span>) <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">st'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">eq_dec_pc</span> (<span class="id" type="var">V.Opsem.st_pc</span> <span class="id" type="var">st'</span>) (<span class="id" type="var">block_entry</span> <span class="id" type="var">lr</span>)) <span class="id" type="keyword">then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">new_dom</span> := (<span class="id" type="var">v</span> :: <span class="id" type="var">mem_dom</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"comp_store_correct: memories mismatch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">memory_on_domain_checker</span> <span class="id" type="var">new_dom</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">V.Opsem.st_mem</span> <span class="id" type="var">st'</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">V.Opsem.Memory.update</span> (<span class="id" type="var">V.Opsem.st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="var">v</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">aeval</span> <span class="id" type="var">a</span> (<span class="id" type="var">V.Opsem.st_mem</span> <span class="id" type="var">st</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> "comp_store_correct: pc not expected" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_store_correct_checker</span>: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">a</span>: <span class="id" type="var">aexp</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">v</span>: <span class="id" type="var">addr</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">lr</span>: <span class="id" type="var">lbl</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">le</span>: <span class="id" type="var">lbl</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> (<span class="id" type="var">gen_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)                      <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ [])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">show_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">vst</span>: <span class="id" type="var">state</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_store_correct_checker_inner</span> <span class="id" type="var">a</span> <span class="id" type="var">v</span> <span class="id" type="var">lr</span> <span class="id" type="var">le</span> <span class="id" type="var">cs</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span> <span class="id" type="var">vst</span>)))))))).<br/>
</div>

<div class="doc">
Exercise: Write a Checker for the following lemma, and make sure that all 
    tests pass.

<div class="paragraph"> </div>

Lemma comp_cond_correct :
  forall g cs b le l<sub>1</sub> l<sub>2</sub> st,
  insns_at_pc g (block_entry le) (steval (comp_cond b l<sub>1</sub> l<sub>2</sub>) cs) -&gt;
  st_pc st = (block_entry le) -&gt;
  exists st',
    plus (step g) st st' /\
    st_pc st' = block_entry (if beval b (st_mem st) then l<sub>1</sub> else l<sub>2</sub>) /\
    st_mem st = st_mem st'.

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_cond_correct_checker_inner</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">b</span>: <span class="id" type="var">bexp</span>) (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) (<span class="id" type="var">le</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>: <span class="id" type="var">lbl</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) (<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) (<span class="id" type="var">vst</span>: <span class="id" type="var">state</span>)<br/>
&nbsp;&nbsp;: <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;FILL&nbsp;IN&nbsp;HERE&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">st</span> := <span class="id" type="var">mkst</span> (<span class="id" type="var">st_mem</span> <span class="id" type="var">vst</span>) (<span class="id" type="var">block_entry</span> <span class="id" type="var">le</span>) (<span class="id" type="var">st_loc</span> <span class="id" type="var">vst</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">st_ppc</span> <span class="id" type="var">vst</span>) (<span class="id" type="var">st_ploc</span> <span class="id" type="var">vst</span>) <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> '(<span class="id" type="var">g</span>, <span class="id" type="var">end_pc</span>) :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">wrap_code_in_cfg</span> (<span class="id" type="var">block_entry</span> <span class="id" type="var">le</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">steval</span> (<span class="id" type="var">comp_cond</span> <span class="id" type="var">b</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span>) <span class="id" type="var">cs</span>) [] <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">let</span> <span class="id" type="var">l</span> := (<span class="id" type="keyword">if</span> <span class="id" type="var">beval</span> <span class="id" type="var">b</span> (<span class="id" type="var">V.Opsem.st_mem</span> <span class="id" type="var">st</span>) <span class="id" type="keyword">then</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="keyword">else</span> <span class="id" type="var">l<sub>2</sub></span>) <span class="id" type="keyword">in</span>  <br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> (<span class="id" type="var">V.Opsem.eval_until_pc</span> <span class="id" type="var">g</span> <span class="id" type="var">st</span> (<span class="id" type="var">block_entry</span> <span class="id" type="var">l</span>) 1000) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inl</span> <span class="id" type="var">err</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;("::: cfg is: " ++ <span class="id" type="var">show</span> <span class="id" type="var">g</span> ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"::: comp_cond_correct: " ++ <span class="id" type="var">err</span> ++<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"::: looking for pc: " ++ <span class="id" type="var">show</span> <span class="id" type="var">end_pc</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">false</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">inr</span> <span class="id" type="var">st'</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">if</span> (<span class="id" type="var">eq_dec_pc</span> (<span class="id" type="var">V.Opsem.st_pc</span> <span class="id" type="var">st'</span>) (<span class="id" type="var">block_entry</span> <span class="id" type="var">l</span>)) <span class="id" type="keyword">then</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">whenFail</span> "comp_store_correct: memories mismatch"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">memory_on_domain_checker</span> <span class="id" type="var">mem_dom</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">st_mem</span> <span class="id" type="var">st</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">st_mem</span> <span class="id" type="var">st'</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">else</span> <span class="id" type="var">whenFail</span> "comp_cond_correct: pc not expected" <span class="id" type="var">false</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">comp_cond_correct_checker</span> : <span class="id" type="var">Checker</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">b</span>: <span class="id" type="var">bexp</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">le</span>: <span class="id" type="var">lbl</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">l<sub>1</sub></span>: <span class="id" type="var">lbl</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">l<sub>2</sub></span>: <span class="id" type="var">lbl</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">cs</span>: <span class="id" type="var">list</span> <span class="id" type="var">uid</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">mem_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAll</span> <span class="id" type="var">arbitrary</span> (<span class="id" type="keyword">fun</span> (<span class="id" type="var">loc_dom</span>: <span class="id" type="var">list</span> <span class="id" type="var">Atom.t</span>) ⇒<br/>
&nbsp;&nbsp;<span class="id" type="var">forAllShrinkShow</span> (<span class="id" type="var">gen_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)                      <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> ⇒ [])<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">show_vminus_state</span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> (<span class="id" type="var">vst</span>: <span class="id" type="var">state</span>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">comp_cond_correct_checker_inner</span> <span class="id" type="var">b</span> <span class="id" type="var">cs</span> <span class="id" type="var">le</span> <span class="id" type="var">l<sub>1</sub></span> <span class="id" type="var">l<sub>2</sub></span> <span class="id" type="var">mem_dom</span> <span class="id" type="var">loc_dom</span> <span class="id" type="var">vst</span>)))))))).<br/>

<br/>
<span class="comment">(*&nbsp;!&nbsp;QuickChick&nbsp;comp_cond_correct_checker.&nbsp;*)</span></div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>